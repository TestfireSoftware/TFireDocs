var documenterSearchIndex = {"docs":
[{"location":"functions/functions_backtest.html#Backtesting-Functions","page":"Backtesting","title":"Backtesting - Functions","text":"","category":"section"},{"location":"functions/functions_backtest.html","page":"Backtesting","title":"Backtesting","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_backtest.html#Scoring-Functions","page":"Backtesting","title":"Scoring - Functions","text":"","category":"section"},{"location":"functions/functions_backtest.html","page":"Backtesting","title":"Backtesting","text":"Modules = [TFire]\nPages   = [\"Trade/Scoring.jl\"]","category":"page"},{"location":"functions/functions_backtest.html#TFire.ScoreHold-Tuple{ScoreBuy, ScoreSell, PortfolioAtDate}","page":"Backtesting","title":"TFire.ScoreHold","text":"ScoreHold(score_buy::ScoreBuy, score_sell::ScoreSell, pf::PortfolioAtDate; cash_score::Float64 = 0.)\n\nBased on a ScoreBuy and a ScoreSell, create a ScoreHold.  An asset is asigned the score in ScoreBuy for all future trading days until either it is subtracted by a score in ScoreSell or it is assigned a higher score from a later date in ScoreBuy. The maximum possible score for any asset in ScoreHold is the maximum score for that asset in ScoreBuy. The minimum score is 0, i.e. score is a nonnegative number. The TradingDates are inferred from the PortfolioAtDate.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.ScoreHold-Tuple{ScoreBuy, ScoreSell, TradingDates}","page":"Backtesting","title":"TFire.ScoreHold","text":"ScoreHold(buy_scores::ScoreBuy, sell_scores::ScoreSell, td::TradingDates; cash_score::Float64 = 0.)\n\nBased on a ScoreBuy and a ScoreSell, create a ScoreHold.  An asset is asigned the score in ScoreBuy for all future trading days until either it is subtracted by a score in ScoreSell or it is assigned a higher score from a later date in ScoreBuy. The maximum possible score for any asset in ScoreHold is the maximum score for that asset in ScoreBuy. The minimum score is 0, i.e. score is a nonnegative number.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.limit_maximum_allocation","page":"Backtesting","title":"TFire.limit_maximum_allocation","text":"limit_maximum_allocation(sh::ScoreHold, max_share::Float64=1.0)::ScoreHold\n\nReadjusts a ScoreHold to limit the risk. max_share is the maximum share of the total score (including cash) that may be from a single asset. The removed score is transferred to cash.\n\n\n\n\n\n","category":"function"},{"location":"functions/functions_backtest.html#TFire.score_extend-Tuple{ScoreBuy, TradingDates}","page":"Backtesting","title":"TFire.score_extend","text":"score_extend(score_buy::ScoreBuy, td::TradingDates; constant_ticks::Integer=0,\nlinear_ticks::Integer=0, trailing_stoploss::Bool=false, trailing_stoploss_val::Float64=0.05)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#Portfolio-Functions","page":"Backtesting","title":"Portfolio - Functions","text":"","category":"section"},{"location":"functions/functions_backtest.html","page":"Backtesting","title":"Backtesting","text":"Modules = [TFire]\nPages   = [\"Trade/Portfolio.jl\"]","category":"page"},{"location":"functions/functions_backtest.html#TFire.TradingDates-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.TradingDates","text":"TradingDates(pf::PortfolioAtDate)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.TradingDates-Tuple{Vector{TimeSeries}}","page":"Backtesting","title":"TFire.TradingDates","text":"TradingDates(vts::Vector{TimeSeries})\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.TradingDates-Union{Tuple{Collection{TFire.AssetsCon{T}}}, Tuple{T}} where T<:TFire.Assets","page":"Backtesting","title":"TFire.TradingDates","text":"TradingDates(col::Collection{AssetsCon{T}}) where T <: Assets\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.get_prices-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.get_prices","text":"get_prices(pf::PortfolioAtDate)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.get_quantities-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.get_quantities","text":"get_quantities(pf::PortfolioAtDate)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.get_tickers-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.get_tickers","text":"get_tickers(pf::PortfolioAtDate)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.get_total_value-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.get_total_value","text":"get_total_value(pf::PortfolioAtDate)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.get_values-Tuple{PortfolioAtDate}","page":"Backtesting","title":"TFire.get_values","text":"get_values(pf::PortfolioAtDate)\n\nReturns a vector containing the total value of each holding in the portfolio  plus the cash amount.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.initialize_portfolio-Union{Tuple{D}, Tuple{T}, Tuple{Collection{TFire.AssetsCon{T}}, D}, Tuple{Collection{TFire.AssetsCon{T}}, D, Float64}} where {T<:TFire.Assets, D<:Union{Date, DateTime}}","page":"Backtesting","title":"TFire.initialize_portfolio","text":"initialize_portfolio(collection::Collection{AssetsCon{T}}, date::D, cash::Float64=1.;verbose=true) where {T <: Assets, D <: Union{Date,DateTime}}\n\nInitializes a portfolio at a given date, usually the first trading date. Makes all assets in the collection available as holdings in the portfolio.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#Portfolio-Propagation-Functions","page":"Backtesting","title":"Portfolio Propagation - Functions","text":"","category":"section"},{"location":"functions/functions_backtest.html","page":"Backtesting","title":"Backtesting","text":"Modules = [TFire]\nPages   = [\"Trade/Trade.jl\"]","category":"page"},{"location":"functions/functions_backtest.html#TFire.PortfolioHistory-Union{Tuple{ScoreHold}, Tuple{D}} where D<:Union{Date, DateTime}","page":"Backtesting","title":"TFire.PortfolioHistory","text":"PortfolioHistory(sh::ScoreHold; start_date::D=Date(0000, 01, 01), to_date::D=Date(0000, 01, 01),\n start_cash=1.0, fee_type=:free, prop_fee=0.0, fixed_fee=0, name=\"\") where {D<:Union{Date,DateTime}}\n\nConstruct a portfolio history by propagating a ScoreHold through time.\n\n# Arguments\n- `sh::ScoreHold`: The ScoreHold to propagate over time.\n- `start_date=DateTime(0000,01,01)`: The start date for the PortfolioHistory.\n- `to_date=D(0000,01,01)`: The end date for the PortfolioHistory.\n- `start_cash=1.`: The starting cash amount. Default is 1.0.\n- `fee_type=:free`: The fee model to use. Can be :free, :fixed, or :prop. Default is :free.\n- `prop_fee=0.`: The proportional fee amount if using :prop fee type.\n- `fixed_fee=0`: The fixed fee amount per trade if using :fixed fee type.\n\n# Returns\n- `PortfolioHistory`: The full portfolio history over time\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.propagate_portfolio-Union{Tuple{D}, Tuple{PortfolioAtDate, ScoreHold}} where D<:Union{Date, DateTime}","page":"Backtesting","title":"TFire.propagate_portfolio","text":"propagate_portfolio(pf::PortfolioAtDate, scoring::ScoreHold; to_date::D=Date(0000,01,01), fee_type=:free, prop_fee=0.,\nfixed_fee=0., keep_weighting_if_unchanged=true, name=\"\") where D <: Union{Date, DateTime}\n\nPropagate a portfolio forward in time by reweighting and stepping forward at each date.\n\n# Arguments\n- `pf::PortfolioAtDate`: The initial portfolio \n- `scoring::ScoreHold`: The scores to use for reweighting  \n- `to_date`: The date to propagate the portfolio to. Default is the max date of the scoring.\n- `fee_type`: The fee model to use. Can be :free, :fixed, :proportional.\n- `prop_fee`: The proportional fee percentage if using :proportional fee model.\n- `fixed_fee`: The fixed fee amount per trade if using :fixed fee model.  \n- `keep_weighting_if_unchanged`: If true, keep the portfolio weighting when no change from scores.\n- `name`: Name given to the propagated portfolio history.\n\n# Returns\n- `PortfolioHistory`: The propagated portfolio history.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#Analysis-Functions","page":"Backtesting","title":"Analysis - Functions","text":"","category":"section"},{"location":"functions/functions_backtest.html","page":"Backtesting","title":"Backtesting","text":"Modules = [TFire]\nPages   = [\"TradeTools/TTPortfolio.jl\"]","category":"page"},{"location":"functions/functions_backtest.html#TFire.maximum_drawdown-Tuple{PortfolioHistory}","page":"Backtesting","title":"TFire.maximum_drawdown","text":"maximum_drawdown(pfh::PortfolioHistory)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.plot_portfolio-Tuple{PortfolioHistory, PortfolioHistory}","page":"Backtesting","title":"TFire.plot_portfolio","text":"plot_portfolio(pfh::PortfolioHistory, pfh2::PortfolioHistory)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.plot_portfolio-Tuple{PortfolioHistory}","page":"Backtesting","title":"TFire.plot_portfolio","text":"plot_portfolio(pfh::PortfolioHistory)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.plot_portfolio-Tuple{Vector{PortfolioHistory}}","page":"Backtesting","title":"TFire.plot_portfolio","text":"plot_portfolio(pfh_vect::Vector{PortfolioHistory})\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.plot_portfolio_proportions-Tuple{PortfolioHistory}","page":"Backtesting","title":"TFire.plot_portfolio_proportions","text":"plot_portfolio_proportions(pfh::PortfolioHistory)\n\nPlots the proportion of total portfolio value held in each asset over time.\n\nCreates a plot with subplots for each asset showing the proportion of the total portfolio value held in that asset over time. Includes a top-level subplot showing the total portfolio value on a secondary y-axis. Limits the number of asset subplots  to a reasonable amount for plot legibility.\n\nArguments:\n\npfh: PortfolioHistory containing the portfolio snapshots over time.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.reference_portfolio-Tuple{PortfolioHistory}","page":"Backtesting","title":"TFire.reference_portfolio","text":"reference_portfolio(pfh::PortfolioHistory)\n\nReturns a portfolio with the same holdings as in pfh.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_backtest.html#TFire.sharpe_ratio-Tuple{PortfolioHistory}","page":"Backtesting","title":"TFire.sharpe_ratio","text":"sharpe_ratio(pfh::PortfolioHistory)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"internet_source_yahoo_data.html#Yahoo-Data","page":"Yahoo Data","title":"Yahoo Data","text":"","category":"section"},{"location":"internet_source_yahoo_data.html","page":"Yahoo Data","title":"Yahoo Data","text":"Available Data Fields for Yahoo Data are :close, :adj_close, :open, :low, :high, :volume\nAvailable tick sizes (resolution) for the last 60 days are 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h \nAvailable tick sizes (resolution) for other time periods are 1d, 5d, 1wk, 1mo, 3mo ","category":"page"},{"location":"internet_source_yahoo_data.html","page":"Yahoo Data","title":"Yahoo Data","text":"CurrentModule = TFire","category":"page"},{"location":"internet_source_yahoo_data.html#Functions","page":"Yahoo Data","title":"Functions","text":"","category":"section"},{"location":"internet_source_yahoo_data.html","page":"Yahoo Data","title":"Yahoo Data","text":"\n\n\n","category":"page"},{"location":"tutorials/tutorial_advanced.html#Tutorial-Advanced","page":"Tutorial - Advanced","title":"Tutorial - Advanced","text":"","category":"section"},{"location":"tutorials/tutorial_advanced.html","page":"Tutorial - Advanced","title":"Tutorial - Advanced","text":"finally make a 2D x-y optimization of EMA-values.","category":"page"},{"location":"tutorials/tutorial_advanced.html","page":"Tutorial - Advanced","title":"Tutorial - Advanced","text":"Skriv den med macd ocksÃ¥? Men med alla tickers","category":"page"},{"location":"collection.html#Collection","page":"Collection","title":"Collection","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The Collection is the centerpiece of TFire. It's a container of Assets,  for example stocks or, in principle, any entity which has associated time series data. Each such Asset is made up of a number of samples which represents individual views (or samples if you wish) of the corresponding time series data.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Some of the benefits of this layout are:","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Layers - A Collection may connect Layers, a form of generalized indicators, to time series data. As the name suggests, these indicators may be layered on top of each other.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Safety - Various safeguards against Look-Ahead is automated, including safe use of repainting indicators.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Manipulation - Collections may be manipulated, accessed and filtered in a multitude of ways including the use of set operations. See Collection Manipulation.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Efficiency - Memory use is minimized, especially in the case of multiple analysis on the same time series.","category":"page"},{"location":"collection.html#Assets","page":"Collection","title":"Assets","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Assets come in two variants, Continuous and Discrete, where the former is used for Assets with a continuous time series, for example a stock at a daily resolutio, or any continously traded asset like crypto curencies and currency pairs, whereas the latter is used when the underlying time series is discontinuous, for example a stock at minute resolution that is not traded 24/7. One collection can only have Assets of one sort.","category":"page"},{"location":"collection.html#Samples","page":"Collection","title":"Samples","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"An Asset contains samples, which link to a part of the associated time series. Every such sample has one evaluation date, which is the last datetime of time series data accessable to the sample. By only evaluating returns after the evaluation date the risk of look ahead is minimized. The recommended way to access time series and Layer data for a sample are through DataViews.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"<center><img src=\"assets/collection_assets.png\" alt=\"drawing\" width=\"300\"/></center>","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"<!--- dev:start --->","category":"page"},{"location":"collection.html#TimeSeriesDataLink-(Developer)","page":"Collection","title":"TimeSeriesDataLink  (Developer)","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The Time Series Data Link, or short TSDLink, is a link between an asset and a time series (typically  residing in the SimpleFastDB). The TSDLink is a subtype of AssetDataLink in a way that another subtype  of AssetDataLink could possibly replace it.","category":"page"},{"location":"collection.html#Technicalities","page":"Collection","title":"Technicalities","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"In practical terms the TSDLink is the uppermost condensate of an asset. It links","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":". It will always  be the uppermost condensate of an asset and is a subtype of AssetDataLink.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"timeseriesrange is a vector of unit ranges where each range is used together with the index_mod","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"of the time series data link together with that of the time series to calculate the range of values   in the linked time series that are used for the sample.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"minimumval and maximumval are the minimum and maximum value in timeseriesrange. They are used","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"for calculating the data range for nonrepainting layers.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"index_mod is copied from the time series in the database at the time of creation of the data link.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"This is to be able to link to the correct place in the time series even after the time series has been  updated with new data.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"<!--- dev:end --->","category":"page"},{"location":"collection.html#Collection-Setup","page":"Collection","title":"Collection Setup","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> spec = Specification([\"AAPL\", \"TSLA\"], Date(2010,1,1), Date(2024,1,1));\n\nTFire> collection = setup_collection(spec)\n-| Collection |- (Continuous)\nTickers: 2, AAPL TSLA\nSamples: 6852","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Here, the Specification specifies which tickers between which dates to include in the collection. It also specifices what data fields (price, volume etc) to use. Since no fields are explictly specified, the default fields are used. We can see that the Collection contains 2 Assets and a total of 6852 Samples","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Every Collection is connected to a SimpleFastDB instance which contains the raw time series data. In the example above, this is handled in the background but may also be explicitly specified:","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> spec = Specification([\"AAPL\", \"TSLA\"], Date(2010,1,1), Date(2024,1,1));\n\nTFire> sfdb = setup_simple_fast_db(spec);\n\nTFire> collection = setup_collection(spec, sfdb);","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"For a more comprehensive example of how to set up a collection from scratch see Tutorial - Basic Analysis of Time Series Data.","category":"page"},{"location":"collection.html#Collection-Settings","page":"Collection","title":"Collection Settings","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The Setting contains all of the Parameters for a Collection and its Layers. Every collection has two associated Settings. The first, settings_used represents the settings that was actually used and thus fully describes the collection. The second one, settings are the settings that will be used if for example a new Layer is added.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The settings of some Collection col may be accessed with col.settings and col.settings_used.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"note: Note\nIt's important to understand and be comfortable with the difference between settings_used and settings.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Example:","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> settings = Settings()\n\nTFire> settings[LayerSMA][:win_sizes] =  [12,26];","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Here we have created a Settings entity and populated it with Parameters related to the Simple Moving Average layer type.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Some specific parameter in the Settings may be accesed with [LayerType][:ParameterName]:","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> settings[LayerSMA][:win_sizes]\n[12, 26]\n","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Trying to access a a LayerType not in the Settings results in an error.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> settings[LayerMACD][:win_sizes]\nERROR: type LayerMACD not in Settings","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Every LayerType comes with default parameters which are used if nothing else is specified.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> default_parameters(LayerSMA)\nLayerSMA\n:price => DefaultPrice()\n:win_sizes => [45, 60]","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The DefaultPrice() is set in the Parameters for TSDLink, which handles the settings for the collection not related to any particular Layer.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> TFire.default_parameters(TSDLink)\nTSDLink\n:resolution => \"1d\"\n:default_price_field => :adj_close_log","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"We can see that the default of the default price field is set to the adjusted closing price. Here is also where the resolution of the time series data in the collection is set. For more functions related to Settings and Parameters see Settings - Functions.","category":"page"},{"location":"collection.html#Collection-Manipulation","page":"Collection","title":"Collection Manipulation","text":"","category":"section"},{"location":"collection.html#Getindex","page":"Collection","title":"Getindex","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Examples of some of the ways of accessing parts of a Collection are presented below. All of the getindex methods presented below creates a new Collection. If instead the Collection is to be modified inplace, the equivalent keepat! method may be used.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Say we have the following Collection,","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection\n-| Collection |- (Continuous)\nTickers: 2, MMM AOS\nSamples: 8562","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The Collection may be accessed by one of the tickers in the Collection or a list of such tickers. This creates a Collection with only those tickers.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection[\"MMM\"]\n-| Collection |- (Continuous)\nTicker: MMM\nSamples: 3352","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The Collection may also be accessed by one date/datetime in the collection, or again, a list of such dates/datetimes. This creates a Collection where only the samples with an evaluation date/datetime equivalent to those requested are kept for all Assets.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection[Date(2010,1,12)]\n-| Collection |- (Continuous)\nTickers: 2, MMM AOS\nSamples: 2","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Further a Collection may be accessed by matching it to another Collection. In the example below the tickers and dates of collection_mmm is used to access collection.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection_mmm = collection[\"MMM\"];\n\nTFire> collection_mmm_new = collection[collection_mmm]\n-| Collection |- (Continuous)\nTicker: MMM\nSamples: 3352\n\nTFire> collection_mmm == collection_mmm_new\ntrue","category":"page"},{"location":"collection.html#Set-Operations","page":"Collection","title":"Set Operations","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Set operations are fully supported on Collections, Below follows some examples of set operations in combination with the getindex methods defined above.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection[\"MMM\"] + collection[\"AOS\"] == collection\ntrue","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Here the + is equivalent to the union operation. ","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection - collection[\"AOS\"] == collection[\"MMM\"]\ntrue","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The - is equivalent to the set difference operation. ","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> intersect(collection, collection[\"MMM\"]) == collection[\"MMM\"]\ntrue","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The intersect function here of course represents the intersect set operation.","category":"page"},{"location":"collection.html#Filtering","page":"Collection","title":"Filtering","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"A Collection may be filtered by a user defined function acting on any DataView of the Collection.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Below is an example taken from Tutorial - Basic Analysis of Time Series Data, where a Collection with an MACD Layer is filtered with a user defined function macd_signal.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> function macd_signal(macd_hist)\n          return macd_hist[end-1] < 0 && macd_hist[end] > 0\n       end\n\nTFire> dv_macd = DVLayerField(collection_macd, :macd_histogram, LayerMACD);\n\nTFire> filter_collection!(collection_macd_copy, dv_macd, macd_signal; action=:keep)","category":"page"},{"location":"collection.html#Donation","page":"Collection","title":"Donation","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Donations of one Collection to another is a way to make data in the donating Collection available through the recieving Collection. Say we have a Collection collection_donator and another, collection_reciever. A DonationProtocol specifies which Assets in collection_donor that donate to which Assets in collection_reciever. One Asset may be donated to several Assets or several to one. If nothing is specified then Assets are matched such that Assets in collection_recieverare recieve a donation from the same Asset in collection_donor. The datetimes of the donor is matched to those of the reciever. A Collation may recieve donations from several Collections.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"note: Note\nThe donating Collection needs to contain all evaluation dates of the recieving Collection.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"note: Note\nWhen a Collection has been donated a copy of the donated Collection is made. This copy is locked and may itself not be modified or donated again.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"note: Note\nIt is possible to receieve donations from several Collections. Hur fungerar det med dataview?","category":"page"},{"location":"collection.html#Uses","page":"Collection","title":"Uses","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"One use of donating Collections is to combine several different Layers on the same Asset. Since one collection may only contain one chain of Layers this has to be done via donations. This is a typical case where every Asset recieves donations from the same Asset in one or several other Collections.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Recieving donations from other Assets is useful either for cases when one Asset is to be traded based on signals from other Assets or if those signals are to be combined with the recieving Asset, for example in the case of correlations studies.","category":"page"},{"location":"collection.html#Performing-Donation","page":"Collection","title":"Performing Donation","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Example:","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> collection_new = donate(collection_reciever, collection_donor);","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"A new Collection collection_new is created by donating collection_donor to collection_reciever. Since no DonationProtocol os specified collection_donor donates Asset with ticker x to Asset with ticker x in collection_reciever.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> dp = dp_all_to_all(collection_reciever, collection_donor);\n\nTFire> collection_new = donate(collection_reciever, collection_donor, dp);","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Here, the shorthand function dp_all_to_all is used to create a DonationProtocol specifying that every Asset in collection_reciever should recieve donations from all Assets in collection_donor.","category":"page"},{"location":"collection.html#Accessing-the-Donated-Data","page":"Collection","title":"Accessing the Donated Data","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"The information from the donated Collection is accessed thorugh special DataViews acting on the donatedassetlink.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Example","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"TFire> col_opt = add_layer(collection, LayerOptimaRolling);\n\nTFire> col_don = donate(col_opt, col_opt); # The Collection is donated to itself.\n\nTFire> a = get_first_asset(col_don[\"MMM\"]); # Returns the asset for ticker \"MMM\"\n\nTFire> dal = get_donated_asset_link(a, \"MMM\"); # Returns the donated asset with ticker \"MMM\" that is linked to the asset with ticker \"MMM\".\n\nTFire> de = DVLayerField(a, :tics); # Creates an ordinary DataView of the \"tics\" field in the outermost layer.\n\nTFire> dem = DVLayerField(dal, :tics); # Creates a DataView of the \"tics\" field from the donated asset.\n\nTFire> de[10] == dem[10] # The two DataViews return the same values.\ntrue\n\nTFire> de[10] === dem[10] # But they are still separate entities.\nfalse\n","category":"page"},{"location":"collection.html#Donate-Functions","page":"Collection","title":"Donate Functions","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"Functions related to Collation donation may be found at Collection Donation - Functions","category":"page"},{"location":"collection.html#Functions","page":"Collection","title":"Functions","text":"","category":"section"},{"location":"collection.html","page":"Collection","title":"Collection","text":"For functions related to the Collection see Collection - Functions.","category":"page"},{"location":"collection.html","page":"Collection","title":"Collection","text":"CurrentModule = TFire","category":"page"},{"location":"history.html#The-History-Behind-TFire","page":"The History Behind TFire","title":"The History Behind TFire","text":"","category":"section"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"Give or take half a decade ago I found myself wanting to backtest strategies based on this new indicator I had envisioned. The indicator in question was of so called repainting type (also sometimes called non-causal), which has to be handled with extra care to avoid the introduction of look-ahead bias.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"I wanted to optimize parameters on this indicator while possibly simultanously combining it with other indicators. I went looking for suitable available tools. I  quickly discarded all backtesting tools with proprietary scripting languages. Partly out of principle but mostly since none seemed good enough for that kind of lock-in.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"Given that I was at the time already writing simple backtests in Python and that the popularity of the language was thorugh the roof with tools such as Pandas, PyTorch and Tensorflow, I decided to write my own backtesting tool in Python. However, after just a few months the realization of the limitations of Python hit me like a brick wall.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"Python itself is famously very very slow and therefore you have to rely on calling C functions acting on vectors. While this works fine for many things, including most traditional machine learning tasks, it is suprisingly ill suited for certain applications. Backtesting being one. Nowdays this has led to the dichotomy of vectorized backtesting vs event driven backtesting in the world of Python based backtesting tools, where the former are known to be fast but inflexible and prone to look-ahead bias and the latter for being slow.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"A couple of months of research followed. I tried to incorporate Numba. I found it to be the worst of both worlds rather than the best of them. Five years later not much has changed in department. In the world of numerical calculations, Python is still best used as a glue language between C functions acting on vectors.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"After having tried a few alternatives I settled on the Julia language. Five years later I have not seen found a more suiting alternative. At a first glance Julia is Python but loops are fast. At a second glance it is multiple dispatch instead of object oriented. Something that may scare you but probably should not. The learning curve going from Python to simple Julia coding is measured in days.","category":"page"},{"location":"history.html","page":"The History Behind TFire","title":"The History Behind TFire","text":"At one point I started to realize that what I had created may in some ways be a better foundation than anything already out there. It was built from ground up to handle both non-repainting and repainting indicators with safeguards against look-ahead. It was flexible yet fairly fast and memory efficient. I decided to try to make it more than a foundation and TFire was born.","category":"page"},{"location":"functions/functions_returns.html#Returns-Functions","page":"Returns","title":"Returns - Functions","text":"","category":"section"},{"location":"functions/functions_returns.html","page":"Returns","title":"Returns","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_returns.html","page":"Returns","title":"Returns","text":"Modules = [TFire]\nPages   = [\"CollectionTools/CTReturns.jl\"]","category":"page"},{"location":"functions/functions_returns.html#TFire.compound_return-Tuple{T} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(dv::T)::Vector{Vector{Float64}} where {T<:FuturePriceView}\n\nCalculates the compound return for FuturePriceView dv.\n\nReturns a vector of vectors containing the compound returns for each sample. The outer vector matches the number of samples. The inner vector matches the number of time steps per sample.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{CDV{T}}, Tuple{T}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(cdv::CDV{T})::Vector{Vector{Vector{Float64}}} where T <: FuturePriceView\n\nCalculates the compound return for a CollectionDataView of FuturePriceView: cdv.\n\nReturns a vector of vectors of vectors containing the compound returns for each sample. The outermost vector matches the  Assets. The middle vector matches the samples. The innermost vector matches the number of time steps.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{Collection}, Tuple{T}, Tuple{Collection, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(c, fut_price_type=FutureAdjClose; flat=false)\n\nCalculates the compound return for Collection c over its samples. \n\nfut_price_type specifies the type of future price data to extract from the Collection. Default is FutureAdjClose.\n\nReturns a vector of vectors of vectors containing the compound returns for each sample. The outermost vector matches the  Assets. The middle vector matches the samples. The innermost vector matches the number of time steps.\n\nIf flat=true, flattens the result into a vector of vectors instead of a vector of vectors of vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{FlatCDV{T}}, Tuple{T}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(fcdv::FlatCDV{T})::Vector{Vector{Float64}} where T <: FuturePriceView\n\nCalculates the compound return for a FlatCollectionDataView of FuturePriceView: cdv.\n\nThe outer vector matches the number of samples over all Assets. The inner vector matches the number of time steps per sample.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{T}, Tuple{CDV{T}, Integer}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(cdv::CDV{T}, steps::Integer)::Vector{Vector{Float64}} where T <: FuturePriceView\n\nCalculates the compound return for each collection data view (CDV) in cdv  over steps time steps. Returns a vector of vectors containing the compound returns for each sample in the CDV.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{T}, Tuple{Collection, Integer}, Tuple{Collection, Integer, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(c::Collection, steps::Integer, fut_price_type::Type{T}=FutureAdjClose; flat::Bool=false) where T <: FuturePriceView\n\nCalculates the compound return from each evaluation date in c over steps time steps. \n\nfut_price_type specifies the type of future price data to extract from the Collection. Default is FutureAdjClose.\n\nIf flat==true gives the returns in a flat vector, otherwise gives the returns in a vector of vectors, in the same structure as CollectionDataViews.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return-Union{Tuple{T}, Tuple{FlatCDV{T}, Integer}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return","text":"compound_return(fcdv::FlatCDV{T}, steps::Integer)::Vector{Float64} where T <: FuturePriceView\n\nCalculates the compound return for each sample in the flattened  collection data view fcdv over steps time steps. Returns a  flattened vector containing the compound returns.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.compound_return_envelope-Union{Tuple{T}, Tuple{Collection, Any}, Tuple{Collection, Any, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.compound_return_envelope","text":"compound_return_envelope(collection::Collection, steps, fut_price_type::Type{T}=FutureAdjClose) where {T<:AbstractFutureAdjClose}\n\nReturns bestreturns, worstreturns\n\nCalculate the envelope of best and worst compound returns for the given Collection  over steps into the future. fut_price_type specifies the type of future adjusted  close price to use in the calculation.\n\nReturns the arithmetic mean best and mean worst cumulative returns as arrays where the first element of respective array is the best respective worst single return of one sample, the second element is the mean of the best and second best respective worst and second worst, etc. up to the last element which is the mean best respective worst over all samples.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.mean_compound_return-Union{Tuple{T}, Tuple{Collection, Any}, Tuple{Collection, Any, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.mean_compound_return","text":"mean_compound_return(collection::Collection, steps, fut_price_type::Type{T}=FutureAdjClose) where T <: AbstractFutureAdjClose\n\nCalculates the mean compound return for fr, a vector of vectors of future returns,  for steps number of steps. Returns a vector where element i is the mean compound return after i steps of all samples that has i available steps in the future returns.\n\nThe same function with equally weighted steps exists as meanlikeweightedcompoundreturn_total()\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.mean_like_weighted_compound_return-Union{Tuple{T}, Tuple{Collection, Any}, Tuple{Collection, Any, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.mean_like_weighted_compound_return","text":"mean_like_weighted_compound_return(collection::Collection, steps, fut_price_type::Type{T}=FutureAdjClose) where T <: AbstractFutureAdjClose\n\nCalculates the mean compound return for fr, a vector of vectors of future returns,  for steps number of steps. Returns a vector where element i is the mean compound return after i steps of all samples that has i available steps in the future returns.\n\nThe return is calculated as if the \"portfolio\" was reweighted to equally weighted each step. The same function without equally weighted steps exists as meancompoundreturn_total()\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.step_return-Union{Tuple{T}, Tuple{CDV{T}, Integer}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.step_return","text":"step_return(cdv::CDV{T}, ind::Integer)::Vector{Vector{Float64}} where T <: FuturePriceView\n\nTakes a CollectionDataView of an FuturePriceView and calculate the step return between time indices ind-1 and ind.\n\nReturns a vector of vectors on the same format as a CollectionDataView.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.step_return-Union{Tuple{T}, Tuple{Collection, Integer}, Tuple{Collection, Integer, Type{T}}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.step_return","text":"step_return(c, ind, fut_price_type=FutureAdjClose; flat=false)\n\nCalculate the step return between time indices ind-1 and ind  for each asset in the Collection c. fut_price_type specifies the type of  future price data to use, defaulting to FutureAdjClose. \n\nIf flat=true, the data is flattened and a flat vector is returned.\n\nReturns a vector or vector of vectors of returns with shape matching the input data.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.step_return-Union{Tuple{T}, Tuple{FlatCDV{T}, Integer}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.step_return","text":"step_return(fcdv::FlatCDV{T}, ind::Integer)::Vector{Float64} where T <: FuturePriceView\n\nTakes a FlatCollectionDataView of an FuturePriceView and calculate the step return between time indices ind-1 and ind.\n\nReturns a vector of the same format as a FlatCollectionDataView.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_returns.html#TFire.step_return-Union{Tuple{T}, Tuple{T, Integer}} where T<:TFire.FuturePriceView","page":"Returns","title":"TFire.step_return","text":"step_return(dv::T, ind::Integer)::Vector{Float64} where T <: FuturePriceView\n\nTakes a FuturePriceView and calculate the step return between time indices ind-1 and ind.\n\nReturns a vector with indices corespoding to the samples in dv.\n\n\n\n\n\n","category":"method"},{"location":"layers_user_defined.html#Creating-User-Defined-Layers","page":"Creating New Layers","title":"Creating User Defined Layers","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"Here is an example of how to add a new user defined layer for calculating simple moving averages (SMA).","category":"page"},{"location":"layers_user_defined.html#Define-The-Layer-Struct","page":"Creating New Layers","title":"Define The Layer Struct","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"mutable struct LayerSMA <: LayersMovingAverage\n    ma_values::Dict{Int64, Vector{Float64}} \nend","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"First, define a mutable struct for the layer. The type of the added layer should be a subtype of some abstryact subtype of AssetLayer - which in this this example menas a subtype of LayersMovingAverage which in its turn is a subtype of AssetLayer.","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"Further, the struct should contain all necessary fields for the layer to store its state. In the case of a non-repainting layer (like SMA) this can often be in the type of Vectors of values, while in the case of a repainting layer it often needs to be Vectors of Vectors of values. Here, the layer supports many window sizes simultaneously and therefore it needs to be a Dict of Vectors.","category":"page"},{"location":"layers_user_defined.html#Define-The-Repainting-Trait","page":"Creating New Layers","title":"Define The Repainting Trait","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"function LayerRepaintingTrait(::Type{<:LayerSMA})\n    return NonRepainting()\nend","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"Next, define a function to specify the repainting trait. SMA is a non-repainting indicator, so return NonRepainting():","category":"page"},{"location":"layers_user_defined.html#Define-Default-Parameters","page":"Creating New Layers","title":"Define Default Parameters","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"Then define a function to return the default parameters for the layer:","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"function default_parameters(::Type{LayerSMA})\n    return Parameters(LayerSMA, Dict{Symbol, Any}(\n        :win_sizes => [45, 60], \n        :price => DefaultPrice()))\nend","category":"page"},{"location":"layers_user_defined.html#Implement-The-Layer-Logic","page":"Creating New Layers","title":"Implement The Layer Logic","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"The main logic goes in _produce_layer. Get the parameters, calculate the SMA values, and return the layer struct. The variable to_keep representing which values to keep is returned along the layer struct.","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"Various types of DataViews are typically used as input. For non-repainting layers it is common to use NonRepainting DataViews.","category":"page"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"function _produce_layer(::Type{LayerSMA}, asset::Asset, settings::Settings, settings_used::Settings; common_input=nothing)\n\n    # input scalars\n    win_sizes = get_parameter(settings, LayerSMA, :win_sizes) \n    price_field = get_parameter(settings, LayerSMA, :price)\n    win_max = maximum(win_sizes)\n\n    # input vectors\n    dvts = DVNonRepaintingTimeSeriesBack(asset, price_field, win_max-1) \n\n    sma_values = Dict{Int64, Vector}()\n\n    for win_size in win_sizes\n        sma = zeros(length(dvts))\n        window = CircularDeque{Float64}(win_size)\n\n        # calculate SMA\n        ...\n\n        sma_values[win_size] = sma\n    end\n\n    # to keep\n    to_keep = trues(length(asset))\n\n    return LayerSMA(sma_values), to_keep\nend","category":"page"},{"location":"layers_user_defined.html#Adding-Layer-Specific-Plotting","page":"Creating New Layers","title":"Adding Layer Specific Plotting","text":"","category":"section"},{"location":"layers_user_defined.html","page":"Creating New Layers","title":"Creating New Layers","text":"function plot_graph(asset::Asset{T,N}, ind::Integer; settings_used=Settings()) where T where N <: LayerSMA\n    # Initialize an array to hold plots, starting with any plots from the parent asset.\n    plots = [plot_graph(asset.parent_asset, ind; settings_used=settings_used)]\n\n    # Retrieve the date indexes for plotting, ensuring alignment with the asset's timeline.\n    x = dates_index_for_plot(asset, settings_used, ind)\n\n    # Extract the window sizes from the layer's settings..\n    win_sizes = settings_used[LayerSMA][:win_sizes]\n\n    # Iterate through each window size to prepare and plot SMA data.\n    for win_size in win_sizes\n        # Extract SMA values for the current window size using the asset and sample index.\n        y = DVLayerDictKey(asset, :ma_values, win_size)[ind]\n\n        # Plotting is performed with PlotlyLight.\n        p = PlotlyLight.Plot(; x=x, y=y, name=\"win size: \"*string(win_size))\n\n        # Add the current plot to the collection of plots to be displayed.\n        push!(plots, p)\n    end\n\n    # Combine all individual plots into a single plot object.\n    # The \"first.(getfield.(plots, :data)) extracts the relevant data from\n    # each plotting object and is a PlotlyLight specific technicality.\n    # Just accept ;)\n    return PlotlyLight.Plot(first.(getfield.(plots, :data)), layout_for_graph())\nend","category":"page"},{"location":"external_data_internet.html#Fetching-Data-from-the-Internet","page":"Data From Internet","title":"Fetching Data from the Internet","text":"","category":"section"},{"location":"external_data_internet.html","page":"Data From Internet","title":"Data From Internet","text":"To fetch data directly from online sources, you can use:","category":"page"},{"location":"external_data_internet.html","page":"Data From Internet","title":"Data From Internet","text":"EDH.fetch_external_data_from_internet(ext_cons, service, data_fields; clean_and_prepare=true, verbose_error=true)","category":"page"},{"location":"external_data_internet.html","page":"Data From Internet","title":"Data From Internet","text":"ext_cons: Specifies which external data constituents to fetch. See Constituents\nservice: The online service to use (e.g., YahooData). See Internet Data Sources\ndata_fields: Dictates which data fields to download. See DataFields.\nclean_and_prepare (optional, default is true): If set to true, the data will be cleaned and prepared after fetching.\nverbose_error (optional, default is true): If true, detailed error messages will be displayed if an error occurs during fetching.","category":"page"},{"location":"external_data_internet.html#Specification-of-Data-to-Fetch","page":"Data From Internet","title":"Specification of Data to Fetch","text":"","category":"section"},{"location":"external_data_internet.html","page":"Data From Internet","title":"Data From Internet","text":"The External DataHandler uses two concepts to specify which data to fetch. The first one, the Constituents is used to  specify which tickers to fetch data for at which time periods. The resolution of the data is also specified. Further, DataFields is used to specify what types of data to include.","category":"page"},{"location":"toc.html#Table-Of-Contents","page":"Table Of Contents","title":"Table Of Contents","text":"","category":"section"},{"location":"toc.html","page":"Table Of Contents","title":"Table Of Contents","text":"","category":"page"},{"location":"tutorials/tutorial_backtest.html#Tutorial-Backtesting","page":"Backtesting","title":"Tutorial - Backtesting","text":"","category":"section"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"If you are completely new to TFire it is recommended to look at Tutorial - Basic Analysis of Time Series Data first.","category":"page"},{"location":"tutorials/tutorial_backtest.html#Setting-up-Scoring","page":"Backtesting","title":"Setting up Scoring","text":"","category":"section"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"The decision of when to buy or sell an asset is done by Scoring the asset. To construct a Scoring we start with a slightly altered version of the setup from Tutorial - Basic Analysis of Time Series Data.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> tickers = [\"MMM\", \"AOS\", \"ABT\", \"ACN\", \"ATVI\"];\n\nTFire> spec = Specification(tickers, Date(2001,6,2),Date(2018,6,8); extend_back=600);\n\nTFire> collection = setup_collection(spec);","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"Let's now cheat and filter out all all dates that have a return after 10 days larger than the average return after 10 days. First we find out what the average return is after 10 trading days","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> ret = compound_return(collection, 10;flat=true);\n\nTFire> mean_return = mean(ret)\n1.0078063862992992","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"Here, we use the compound_return function to calculate the return after 10 days. flat=true is used to flatten the returned values into a vector. Finally, we use the mean function to get the average return after 10 days.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"Now we can filter out the dates that have a return larger than the average return after 10 days. First let's create a function that returns true if a value is larger than the average return after 10 days.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> function higher_than_average(args)\n       x = args[1]\n       return x > 1.0078063862992992\n       end","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"then filter a copy of the original collection","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> collection_higher = copy_collection(collection);\n\nTFire> cret = compound_return(collection, 10);\n\nTFire> filter_collection!(collection_higher, cret, higher_than_average;action=:keep)","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"We can compare the number of samples in the original collection and the filtered collectio and notice that as expected about half of the samples had a higher return than the average sample.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> collection\n-| Collection |- (Continuous)\nTickers: 5, MMM AOS ABT ACN ATVI\nSamples: 21373\n\nTFire> collection_higher\n-| Collection |- (Continuous)\nTickers: 5, MMM AOS ABT ACN ATVI\nSamples: 10759","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"Now it's time to create the actual Scoring.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> score_buy = ScoreBuy(collection_higher, 1.);","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"This function creates a ScoreBuy where every date contained in collection_higher, i.e. all dates that have higher than average return after 10 days, gets a score of 1.","category":"page"},{"location":"tutorials/tutorial_backtest.html#Setting-up-an-Initial-Portfolio","page":"Backtesting","title":"Setting up an Initial Portfolio","text":"","category":"section"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> from_date = DateTime(2002,1,7)\n\nTFire> port = initialize_portfolio(collection, from_date);","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"Let's hold the assets for 10 days after they were bought.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> score_hold = score_extend(score_buy, port; constant_ticks=10);","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"This creates a ScoreHold object, which has a score of 1 for every date in ScoreBuy and 10 days forward.","category":"page"},{"location":"tutorials/tutorial_backtest.html#Propagating-the-Portfolio","page":"Backtesting","title":"Propagating the Portfolio","text":"","category":"section"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"We can propagate the initial portfolio port using the score_hold to get a PortfolioHistory.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> port_prop = propagate_portfolio(port, DateTime(2018,6,8), score_hold)\n-| Portfolio History |-  4135 number of steps from 2002-01-07T00:00:00 to 2018-06-08T00:00:00","category":"page"},{"location":"tutorials/tutorial_backtest.html#Analysing-the-Results","page":"Backtesting","title":"Analysing the Results","text":"","category":"section"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"To evaluate the performance of our portfolio, we begin by plotting it against a portfolio where the same stocks are bought for equal ammount at day 1 and then held to the final day, i.e. equal weighted buy and hold. We can get this portfolio by running reference_portfolio(port_prop).","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> plot_portfolio(port_prop, reference_portfolio(port_prop))","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"(Image: Portfolio Plot) The cheating portfolio is of course significantly outperforming the buy and hold variant, with a 600x return vs 20x return over the time period.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"We can add a trading fee of 1% on all trades and see what that does.","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"TFire> port_prop_fee = propagate_portfolio(port, DateTime(2018,6,8), score_hold; fee_type=:proportional, prop_fee=0.01)\n\nTFire> plot_portfolio(port_prop_fee, reference_portfolio(port_prop_fee))","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"(Image: Portfolio With Fee Plot)","category":"page"},{"location":"tutorials/tutorial_backtest.html","page":"Backtesting","title":"Backtesting","text":"That concludes this tutorial on the basics of backtesting in TFire.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"Give or take half a decade ago I found myself wanting to backtest strategies based on this new indicator I had envisioned. The indicator in question was of so called repainting type (also sometimes called non-causal), which has to be handled with extra care to avoid the introduction of look-ahead bias.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"I wanted to optimize parameters on this indicator while possibly simultanously combining it with other indicators. I went looking for suitable available tools. I  quickly discarded all backtesting tools with proprietary scripting languages. Partly out of principle but mostly since none seemed good enough for that kind of lock-in.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"Given that I was at the time already writing simple backtests in Python and that the popularity of the language was thorugh the roof with tools such as Pandas, PyTorch and Tensorflow, I decided to write my own backtesting tool in Python. However, after just a few months the realization of the limitations of Python hit me like a brick wall.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"Python itself is famously very very slow and therefore you have to rely on calling C functions acting on vectors. While this works fine for many things, inclusing most traditional machine learning tasks, it is suprisingly ill suited for some applications. Backtesting being one. Nowdays this has led to the dichotomy of vectorized backtesting vs event driven backtesting in the world of Python based backtesting tools, where the former are known to be fast but inflexible and prone to look-ahead bias and the latter for being slow.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"A couple of months of research followed. I tried to incorporate Numba. It tries to tie a messy subset of Python to Python. I found it to be more of the worst of both worlds than the best of them. Five years later not much has changed. Python is still best used as a glue language between C functions acting on vectors.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"After having tried a few alternatives I settled on the Julia language. Five years later I have not seen found a more suiting alternative. At a first glance Julia is Python but loops are fast. At a second glance it is multiple dispatch instead of object oriented. Something that may scare you but probably should not. The learning curve going from Python to simple Julia coding is measured in days.","category":"page"},{"location":"why_tfire.html","page":"-","title":"-","text":"At one point I started to realize that what I had created may in some ways be a better foundation than anything already out there. It was built from ground up to handle both non-repainting and repainting indicators with safeguards against look-ahead. It was flexible yet fairly fast and memory efficient. I decided to try to make it more than a foundation and TFire was born.","category":"page"},{"location":"data_views.html#DataViews","page":"DataViews","title":"DataViews","text":"","category":"section"},{"location":"data_views.html#AssetDataViews","page":"DataViews","title":"AssetDataViews","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"DataViews are a way to access either raw time series data or Layer data related to an Asset (see Assets) or a Collection.","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"For example, if a is an Asset that has a corresponding times series with the field name :volume, then dv = DVTimeSeries(a, :volume) creates a DVTimeSeries  (short for DataViewTimeSeries) which is a subtype to AssetDataView. dv[i][j] then gives the j:th value of the i:th sample, or simplydv[i] gives the whole view  of the volume field that is related to the i:th sample. ","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"Likewise, if we have dvl = DVLayerField(a, :field_name, LayerType), then dv[i][j] gives  j:th value of the i:th sample for the field :field_name in the Layer of type LayerType. Here, and in many other cases, the LayerType may be completely omitted if the desired Layer is the outhermost one of the Layers in the Asset.","category":"page"},{"location":"data_views.html#CollectionDataViews","page":"DataViews","title":"CollectionDataViews","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"If instead c is a Collection then cdv = DVTimeSeries(c, :volume) creates a  CDV{DVTimeSeries}  (where CDV is short for CollectionDataView) which contains the DVTimeSeries for every Asset in the Collection. Then cdv[1] == DVTimeSeries(a, :volume) for the first Asset a given by the iterator over all Assets. cdv[i][j][k] thus gives the k:th value of the time series of :volume corresponding to the j:th sample in the  i:th Asset. ","category":"page"},{"location":"data_views.html#FlatCDV","page":"DataViews","title":"FlatCDV","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"The CDV may also be flattened to a FlatCDV. If fcdv = FlatCDV(cdv) then the views for all samples in the Collection are stored in one dimension so that fcdv[i] gives the corresponding view of the :volume field for the i:th sample in the whole Collection. ","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"The FlatCDV is useful when the value for two different fields are to be compared for the same sample without the need to know which precise sample it is. For example if the correlation between two different fields are to be calculated for all samples in a Collection.","category":"page"},{"location":"data_views.html#NonRepainting-DataViews","page":"DataViews","title":"NonRepainting DataViews","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"The NonRepainting Dataviews are useful when constructing NonRepainting Layers. If a is an Asset that has a corresponding times series with the field name :volume, then dv = DVNonRepaintingTimeSeries(a, :volume) creates a  NonRepaintingDVTimeSeries.. dv then contains a view of the volume field from the first datetime contained in any of the Asset's samples to the last datetime  contained in any of the samples.","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"Below is an example of the use of a NonRepainting DataView taken from the code creating the SMA Layer used in TFire. Since the Simple Moving Average indicator is a non repainting indicator a NonRepainting DataView is used to access the price data.","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"# input vectors\ndvts = DVNonRepaintingTimeSeries(asset, price_field)","category":"page"},{"location":"data_views.html#DonatedDataViews","page":"DataViews","title":"DonatedDataViews","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"Data Views on donated Assets/Collections (see Donation) work just like ordinary DataViews with the exception that the DataView should be applied to a DonatedAssetLink and not to an Asset. ","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"Example:","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"TFire> collection_sma = add_layer(collection, LayerSMA);\n\nTFire> collection = collection[collection_sma]; # This removes dates that are in collection but not in collection_sma\n\nTFire> col_donated = donate(collection, collection_sma);\n\nTFire> asset_don = get_first_asset(col_donated) # special function to get first asset of a Collection. Useful for debugging etc.\n-| Asset |-\nTicker: MMM\nSamples: 2020\n\nTFire> donated_dv = DVLayerDictKey(get_donated_asset_link(asset_don, \"MMM\"), :ma_values, 26)","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"In the example above we can access the Simple Moving Average Layer from another Collection.","category":"page"},{"location":"data_views.html#FuturePriceView","page":"DataViews","title":"FuturePriceView","text":"","category":"section"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"A special kind of DataView category is the FuturePriceView. It's the only DataView that is allowed access to data past the evaluation date, specificallt price data. Its primary use is to calculate future returns (see Returns) after the evaluation date.","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"CurrentModule = TFire","category":"page"},{"location":"data_views.html","page":"DataViews","title":"DataViews","text":"For a list of related functions see DataViews - Functions.","category":"page"},{"location":"functions/functions_specification.html#Specification-Functions","page":"Specification","title":"Specification - Functions","text":"","category":"section"},{"location":"functions/functions_specification.html","page":"Specification","title":"Specification","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_specification.html","page":"Specification","title":"Specification","text":"Modules = [TFire]\nPages   = [\"Core/Specifications.jl\"]","category":"page"},{"location":"functions/functions_specification.html#TFire.constituents_continuous-Union{Tuple{D}, Tuple{Vector{String}, Array{Tuple{D, D}, 1}, String}} where D<:Union{Date, DateTime}","page":"Specification","title":"TFire.constituents_continuous","text":"constituents_continuous(tickers::Vector{String}, dates_vect::Vector{Tuple{D,D}},\nresolution::String) where {D<:Union{Date,DateTime}}\n                             resolution::String)\n\nConstructs ConstituentsConstinues from a list of tickers and a \n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.constituents_continuous-Union{Tuple{D}, Tuple{Vector{String}, Vector{D}, Integer}} where D<:Union{Date, DateTime}","page":"Specification","title":"TFire.constituents_continuous","text":"constituents_continuous(tickers::Vector{String}, eval_dates::Vector{D},\nextend_back::Integer; resolution=\"1d\") where {D<:Union{Date,DateTime}}\n\nConstructs a ConstituentsContinuous from a vector of tickers, evaluation dates, and an extend back period.  The extend back determines how far before each evaluation date to include data. The resolution determines the type of the eval_dates and how to calculate the extend back.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.extend_sfdb_constituents!-Union{Tuple{TFire.ExternalDataHandler.ConstituentsContinuous{D, T}}, Tuple{T}, Tuple{D}} where {D<:Date, T<:SFDBSpecification}","page":"Specification","title":"TFire.extend_sfdb_constituents!","text":"extend_sfdb_constituents!(rc::ConstituentsContinuous{D,T}; extend_first=Day(0),\nextend_last=Day(0)) where {D<:Date,T<:SFDBSpecification}\n                           extend_last=Day(0))\n\nExtends the date range for each ticker in the given ConstituentsContinuous  with SFDBSpecification by shifting the start date back by extend_first and  the end date forward by extend_last. Doesnt extend past current date.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.extend_sfdb_constituents!-Union{Tuple{TFire.ExternalDataHandler.ConstituentsContinuous{D, T}}, Tuple{T}, Tuple{D}} where {D<:DateTime, T<:SFDBSpecification}","page":"Specification","title":"TFire.extend_sfdb_constituents!","text":"extend_sfdb_constituents!(rc::ConstituentsContinuous{D,T}; extend_first=Day(0),\nextend_last=Day(0)) where {D<:DateTime,T<:SFDBSpecification}\n                           extend_last=Day(0))\n\nExtends the date range for each ticker in the given ConstituentsContinuous with SFDBSpecification by shifting the start date back by extend_first and the end date forward by extend_last.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.preset_data_fields-Union{Tuple{S}, Tuple{Symbol, Type{S}}} where S<:TFire.ExternalDataHandler.SpecificationType","page":"Specification","title":"TFire.preset_data_fields","text":"preset_data_fields(sym::Symbol, s::Type{S}) where S <: SpecificationType\n\nPresets the data fields for a CollectionSpecification based on the symbol sym. Allows selecting common preset configurations like :normal, :reduced etc.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.sfdb_constituents-Tuple{TFire.ExternalDataHandler.ConstituentsDiscrete{CollectionSpecification}}","page":"Specification","title":"TFire.sfdb_constituents","text":"sfdb_constituents(cons::ConstituentsDiscrete{CollectionSpecification})\n\nConverts a ConstituentsDiscrete with CollectionSpecification to one with  SFDBSpecification by collapsing the date ranges for each ticker on each date into a single range from the start of the day to the end of the day.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.sfdb_constituents-Union{Tuple{TFire.ExternalDataHandler.ConstituentsContinuous{D, CollectionSpecification}}, Tuple{D}} where D<:Union{Date, DateTime}","page":"Specification","title":"TFire.sfdb_constituents","text":"sfdb_constituents(cons::ConstituentsContinuous{D,CollectionSpecification}) where {D<:Union{Date,DateTime}}\n\nConverts a ConstituentsContinuous with CollectionSpecification to one with SFDBSpecification  by collapsing the date ranges for each ticker into a single range from the earliest start date to the latest end date.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.specification_external-Union{Tuple{SpecificationStruct{C, T}}, Tuple{T}, Tuple{C}} where {C<:AssetConstituents, T<:SFDBSpecification}","page":"Specification","title":"TFire.specification_external","text":"specification_external(spec::Specification{C,T}) where {C<:AssetConstituents,T<:SFDBSpecification}\n\nConverts a Specification with SFDBSpecification to one with ExternalSpecification  by converting the constituents to use ExternalSpecification and converting the  data fields to use non logarithmized versions.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_specification.html#TFire.specification_sfdb-Union{Tuple{SpecificationStruct{C, T}}, Tuple{T}, Tuple{C}} where {C<:AssetConstituents, T<:CollectionSpecification}","page":"Specification","title":"TFire.specification_sfdb","text":"specification_sfdb(spec::Specification{C,T}; extend_first=Day(1000),\nextend_last=Day(1000)) where {C<:AssetConstituents,T<:CollectionSpecification}\n                   extend_last=Day(1000)) where {C<:AssetConstituents, T<:CollectionSpecification}\n\nConverts a Specification with CollectionSpecification to one with  SFDBSpecification by collapsing the date ranges for each ticker into a  single range from the earliest start date to the latest end date.\n\n\n\n\n\n","category":"method"},{"location":"back_testing.html#Backtesting","page":"Backtesting","title":"Backtesting","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Backtesting in TFire is carried out by propagating a PortfolioHistory forward in time, see Propagating The Portfolio. Each timestep of the PortfolioHistory contains a PortfolioAtDate object which contains the information about holding quantities at that date. At every timestep the portfolio is reweighted based on a scoring function, see Portfolio Weightings from ScoreHold.","category":"page"},{"location":"back_testing.html#Scoring","page":"Backtesting","title":"Scoring","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"To determine which holdings to buy and sell, TFire uses a scoring function. When propagating the PortfolioHistory the weighting of each holding is determined by a ScoreHold object that for each holding and trading date contains a nonnegative real number representing its score. The ScoreHold also contains a score for cash at each trading date.","category":"page"},{"location":"back_testing.html#Portfolio-Weightings-from-ScoreHold","page":"Backtesting","title":"Portfolio Weightings from ScoreHold","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"The weighting of holding k at timestep i is calculated as follows:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"textweight_k i = fractextscore_k isum_k textscore_k i + textscore_textcash i","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"where \ntextweight_k i represents the weighting of holding k at timestep i  \ntextscore_k i represents the score of holding k at timestep i  \ntextscore_textcash i represents the score of cash at timestep i ","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"And of course the weighting of cash at timestep i is:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"textweight_textcash i = fractextscore_cash isum_k textscore_k i + textscore_textcash i","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"The sum of all weights always equals 1.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"sum_k textweight_k i + textscore_cash i = 1","category":"page"},{"location":"back_testing.html#Constructiong-ScoreHold","page":"Backtesting","title":"Constructiong ScoreHold","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A ScoreHold may be constructed in several different ways. Below follows a description of the two most common ways.","category":"page"},{"location":"back_testing.html#ScoreHold-From-ScoreBuy-and-ScoreSell","page":"Backtesting","title":"ScoreHold From ScoreBuy and ScoreSell","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A ScoreHold may be created by combining a ScoreBuy and a ScoreSell:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"ScoreHold(buy_scores::ScoreBuy, sell_scores::ScoreSell, td::TradingDates)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"When a holding is given a score from ScoreBuy the ScoreHold keeps that score for all future trading dates until either a new higher score is obtained from ScoreBuy or the score is subtracted by a score in ScoreSell.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"An example may make this more clear. Say we have a Portfolio with only one potential holding.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Trading Day ScoreHold ScoreBuy ScoreSell\n1 0. - -\n2 1. 1. -\n3 1. 0.7 -\n4 2. 2. -\n5 2. - -\n6 1.5 - 0.5\n7 0. - 3.\n8 0. 1. 3.","category":"page"},{"location":"back_testing.html#ScoreHold-From-Extending-ScoreBuy","page":"Backtesting","title":"ScoreHold From Extending ScoreBuy","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A ScoreHold may be created by extending a ScoreBuy:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"score_extend(score_buy::ScoreBuy, td::TradingDates)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"We may again clarify this with an example portfolio with one holding. Here we extend it by 3 constant trading dates (this includes the ScoreBuy date) and then a linear fallof of 3 dates.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"TFire> score_extend(score_buy::ScoreBuy, td::TradingDates; constant_ticks=3,linear_ticks=3)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Trading Day ScoreHold ScoreBuy\n1 0. -\n2 1. 1.\n3 1. -\n4 1. -\n5 0.75 -\n6 0.5 -\n7 0.25 -","category":"page"},{"location":"back_testing.html#Portfolio","page":"Backtesting","title":"Portfolio","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A portfolio at one single time is represented by a PortfolioAtDate object. It contains the information about the quantity of all holdings and cash at that date. A PortfolioHistory contains two PortfolioAtDate objects per trading date, one that represents the portfolio before holdings are reweighted and one after.","category":"page"},{"location":"back_testing.html#PortfolioAtDate","page":"Backtesting","title":"PortfolioAtDate","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"if pfad is a PortfolioAtDate then","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"get_tickers(pfad) returns a vector with the tickers of all holdings in the PortfolioAtDate","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"get_quantities(pfad) returns a vector with the quantities of all holdings in the PortfolioAtDate","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"get_prices(pfad) returns a vector with the prices of all holdings in the PortfolioAtDate","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"get_values(pfad) returns a vector with the values of all holdings in the PortfolioAtDate","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"All vectors are in the same order.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Further","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"pfad.cash returns the cash in the PortfolioAtDate\npfad.date returns the date of the PortfolioAtDate","category":"page"},{"location":"back_testing.html#Setup-of-PortfolioAtDate","page":"Backtesting","title":"Setup of PortfolioAtDate","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"To setup an initial PortfolioAtDate from a Collection we use the initialize_portfolio() function. The function takes a Collection and a datetime and creates a PortfolioAtDate at that datetime with all the Assets in the Collection available as holdings. It also takes a cash argument which will set the amount of cash available. All holding qunatities are set to 0.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"note: Note\nAll holdings that are to be potentially bought or sold in the PortfolioHistory needs to exist in the initial PortfolioAtDate.","category":"page"},{"location":"back_testing.html#PortfolioHistory","page":"Backtesting","title":"PortfolioHistory","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"If pfh is a PortfolioHistory then","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"pfh.name returns or sets the name of the portfolio.\npfh.pf_before_rw returns a vector of PortfolioAtDate objects representing the portfolio before holdings are reweighted for each trading date.\npfh.pf_after_rw returns a vector of PortfolioAtDate objects representing the portfolio after holdings are reweighted for each trading date.","category":"page"},{"location":"back_testing.html#Propagating-The-Portfolio","page":"Backtesting","title":"Propagating The Portfolio","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A PortfolioHistory may be created either from propagating a PortfolioAtDate or directly from a ScoreHold. At each timestep the portfolio is reweighted according to the ScoreHold. Both methods support both a constant and a proportional fee which is applied directly at the time of reweighting the portfolio.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"propagate_portfolio() is a function that propagates a portfolio over time based on a set of scores.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"It takes a portfolio at a starting date (pf) and a set of scores over time (scoring) as inputs. The other inputs are optional parameters that control how the propagation happens:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"to_date - the date to propagate the portfolio to. By default it propagates to the last date in the scores.\nfee_type - the fee model to use. Can be :free, :fixed, :proportional. Default is :free.  \nprop_fee - the proportional fee percentage if using :proportional fee model.\nfixed_fee - the fixed fee amount per trade if using :fixed fee model.\nkeep_weighting_if_unchanged - whether to keep the portfolio weighting the same if no scores are available for a date. Default true.\nname - a name string for the portfolio. Default is a random string.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"It returns a PortfolioHistory object, which contains the portfolio before and after reweighting on each date.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"The function works by stepping through time, reweighting the portfolio on each date based on the scores for that date, and stepping the portfolio forward by making the necessary trades to rebalance.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"It first finds the date range to iterate over based on the input portfolio, scores, and to_date.  ","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"It initializes a PortfolioHistory object to store the results.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Then it loops through each date:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Calls weightingfromscores to get target weights from the scores.\nReweights the portfolio to those targets with reweightportfolio. Applies fees based on feetype.  \nSteps the portfolio to the next date by making the trades needed.\nStores the portfolio before and after reweighting on that date.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"So in summary, it takes a starting portfolio and scores, and propagates it through time by reweighting and rebalancing on each date to follow the scores. The output is a full history of the portfolio over time.","category":"page"},{"location":"back_testing.html#PortfolioHistory-from-PortfolioAtDate","page":"Backtesting","title":"PortfolioHistory from PortfolioAtDate","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"When starting from a PortfolioAtDate we use the propagate_portfolio() function. This function takes a PortfolioAtDate, a datetime which to propagate to and a ScoreHold. The TradingDates used are determined from the input portfolio.","category":"page"},{"location":"back_testing.html#PortfolioHistory-from-ScoreHold","page":"Backtesting","title":"PortfolioHistory from ScoreHold","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"A PortfolioHistory may also be created directly from a ScoreHold:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"PortfolioHistory(sh::ScoreHold;start_date=DateTime(0000,01,01), start_cash=1., fee_type=:free, prop_fee=0., fixed_fee=0)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Since no PortfolioAtDate is given the PortfolioHistory is created with all the holdings in the ScoreHold available. The start_date and start_cash are optional. The portfolio is propagated to the last date in ScoreHold.","category":"page"},{"location":"back_testing.html#Analysis-of-PortfolioHistory","page":"Backtesting","title":"Analysis of PortfolioHistory","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"The following mostly self explanatory functions are useful when evaluationg a trading strategy:","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"sharpe_ratio(pfh::PortfolioHistory)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"maximum_drawdown(pfh::PortfolioHistory)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"plot_portfolio(pfh::PortfolioHistory)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"plot_portfolio(pfh::PortfolioHistory, pfh2::PortfolioHistory)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"plot_portfolio(pfh_vect::Vector{PortfolioHistory})","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"plot_portfolio_proportions(pfh::PortfolioHistory)","category":"page"},{"location":"back_testing.html#Trading-Dates","page":"Backtesting","title":"Trading Dates","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"When propagating a portfolio, all trading dates between the start date and the finish date needs to be specified by a TradingDates object which contains a chronologically sorted vector of trading dates. Often it may be automatically deduced but sometimes it needs to be explicitly created. Below follows a few ways of creating it.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"TradingDates(col::Collection) where T <: Assets ","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Creates TradingDates from a Collection.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"TradingDates(vts::Vector{TimeSeries}) ","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Creates TradingDates from a vector of TimeSeries.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"TradingDates(pf::PortfolioAtDate)","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"Creates TradingDates from a PortfolioAtDate.","category":"page"},{"location":"back_testing.html#Functions","page":"Backtesting","title":"Functions","text":"","category":"section"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"For a list of related functions see Backtesting - Functions.","category":"page"},{"location":"back_testing.html","page":"Backtesting","title":"Backtesting","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_collection.html#Collection-Functions","page":"Collection","title":"Collection - Functions","text":"","category":"section"},{"location":"functions/functions_collection.html","page":"Collection","title":"Collection","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_collection.html","page":"Collection","title":"Collection","text":"Modules = [TFire]\nPages   = [\"Collection.jl\"]","category":"page"},{"location":"functions/functions_collection.html#TFire.condensate_type-Tuple{Collection}","page":"Collection","title":"TFire.condensate_type","text":"condensate_type(col::Collection)\n\nThe type of the outermost (latest) condensate in the assets of the collection.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.copy_collection-Tuple{Collection}","page":"Collection","title":"TFire.copy_collection","text":"copy_collection(col::Collection)\n\nReturns a deepcopy of the collection.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.get_first_asset-Tuple{Collection}","page":"Collection","title":"TFire.get_first_asset","text":"get_first_asset(collection::Collection{T}) where T <: Assets\n\nReturns the first asset from the iterator over all the assets in the collection. Useful if one needs to get an asset but doesn't care which.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.get_tickers-Tuple{Collection}","page":"Collection","title":"TFire.get_tickers","text":" get_tickers(col::Collection)\n\nReturns a vector with the names of all the tickers in the collection. For continuous assets the names are ordered as the assets.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.has_layer_type-Union{Tuple{T}, Tuple{Collection, Type{T}}} where T<:AssetLayer","page":"Collection","title":"TFire.has_layer_type","text":"has_layer_type(col::Collection, lay_typ::Type{T}) where T <: AssetLayer\n\nReturns true if collection has layer type in chain of layers. Otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.list_layer_types-Tuple{Collection}","page":"Collection","title":"TFire.list_layer_types","text":"list_layer_types(col::Collection)\n\nReturns a vector with the condensate types for the assets in the collection. Outermost condensate first.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.number_of_samples-Tuple{Collection}","page":"Collection","title":"TFire.number_of_samples","text":"number_of_samples(col::Collection)\n\nTotal number of samples for all assets in collection.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.setup_collection-Union{Tuple{T}, Tuple{C}, Tuple{SpecificationStruct{C, T}, SimpleFastDB}} where {C<:AssetConstituents, T<:CollectionSpecification}","page":"Collection","title":"TFire.setup_collection","text":"setup_collection(spec::Specification{C,T}, sfdb::SimpleFastDB) where {C<:AssetConstituents, T<:CollectionSpecification}\n\nReturns a vector with the names of all the tickers in the collection. For continuous assets the names are ordered as the assets.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#Collection-Settings-Functions","page":"Collection","title":"Collection Settings - Functions","text":"","category":"section"},{"location":"functions/functions_collection.html","page":"Collection","title":"Collection","text":"Modules = [TFire]\nPages   = [\"Settings.jl\"]","category":"page"},{"location":"functions/functions_collection.html#TFire.add!-Tuple{Settings, Parameters}","page":"Collection","title":"TFire.add!","text":"add!(settings::Settings, param::Parameters)\n\nAdds parameters params into settings.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.add_and_replace_parameters!-Tuple{Settings, Settings}","page":"Collection","title":"TFire.add_and_replace_parameters!","text":"add_and_replace_parameters(set::Settings, set_add::Settings)\n\nAdds all parameters in set_add to set. Replaces already existing parameters.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.add_missing!-Tuple{Settings, Parameters}","page":"Collection","title":"TFire.add_missing!","text":"add_missing!(settings::Settings, params::Parameters)\n\nAdds parameters params into settings only if they do not already exist in setingst.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.check_settings_valid-Tuple{Settings}","page":"Collection","title":"TFire.check_settings_valid","text":"check_settings_valid(settings::Settings) -> Bool\n\nValidate Settings by checking each type should be a concrete subtype of Condensate  and each parameter should be a key in the default parameters for that type, with a value of the correct type.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.get_parameter-Tuple{Settings, Type, Symbol}","page":"Collection","title":"TFire.get_parameter","text":"get_parameter(settings::Settings, layer_type::Type, key::Symbol)\n\nReturns the parameter value unless key is subtype of DefaultParameter  in which case a special value defined by the type of key is returned.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#Collection-Donation-Functions","page":"Collection","title":"Collection Donation - Functions","text":"","category":"section"},{"location":"functions/functions_collection.html","page":"Collection","title":"Collection","text":"Modules = [TFire]\nPages   = [\"CollectionDonation.jl\"]","category":"page"},{"location":"functions/functions_collection.html#TFire.donate-Tuple{Collection, Collection}","page":"Collection","title":"TFire.donate","text":"donate(col_reciever::Collection, col_donor::Collection;\n                        dp::Union{DonationProtocol, Nothing}=nothing)\n\ncoldonor is donated to colreciever such that a new collection is created\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.donor_or_reciever-Tuple{Collection}","page":"Collection","title":"TFire.donor_or_reciever","text":"donor_or_reciever(collection::Collection)\n\nReturns true if collection is either a donor, a reciever or both.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.dp_all_to_all-Tuple{Collection, Collection}","page":"Collection","title":"TFire.dp_all_to_all","text":"dp_all_to_all(col_reciever::Collection, col_donor::Collection)\n\nReturns a donation protocol where every ticker t in colreciever links to a vector of all tickers in coldonor.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_collection.html#TFire.dp_same_tickers-Tuple{Collection}","page":"Collection","title":"TFire.dp_same_tickers","text":"dp_same_tickers(col::Collection)\n\nReturns a donation protocol where every ticker t in col links to a vector of length one with the same ticker t.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#External-Data-Handler-Functions","page":"External Data Handler","title":"External Data Handler - Functions","text":"","category":"section"},{"location":"functions/functions_edh.html","page":"External Data Handler","title":"External Data Handler","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_edh.html#External-Data-From-Disk","page":"External Data Handler","title":"External Data From Disk","text":"","category":"section"},{"location":"functions/functions_edh.html","page":"External Data Handler","title":"External Data Handler","text":"Modules = [ExternalDataHandler]\nPages   = [\"ExternalDataRead/ExternalDataFromDisk.jl\"]","category":"page"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.ExternalDataCollection-Tuple{TFire.ExternalDataHandler.ExternalDataFile}","page":"External Data Handler","title":"TFire.ExternalDataHandler.ExternalDataCollection","text":"ExternalDataCollection(edf::ExternalDataFile)\n\nReconstructs an ExternalDataCollection from an ExternalDataFile structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.ExternalDataFile-Tuple{TFire.ExternalDataHandler.ExternalDataCollection}","page":"External Data Handler","title":"TFire.ExternalDataHandler.ExternalDataFile","text":"ExternalDataFile(edc::ExternalDataCollection)\n\nConstructs an ExternalDataFile from an ExternalDataCollection. Ensures that all data assets in the collection have the same resolution,  and organizes them into a dictionary of tickers for easy lookup.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.external_data_paths_from_csv-Tuple{String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.external_data_paths_from_csv","text":"external_data_paths_from_csv(fname::String)\n\nGiven a CSV filename, extracts and returns the relative paths to data files specified in it. Ensures the input file has a CSV extension before processing.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.fetch_external_data_from_disk-Union{Tuple{T}, Tuple{C}, Tuple{SpecificationStruct{C, T}, String, String}} where {C<:AssetConstituents, T<:TFire.ExternalDataHandler.ExternalSpecification}","page":"External Data Handler","title":"TFire.ExternalDataHandler.fetch_external_data_from_disk","text":"fetch_external_data_from_disk(spec::SpecificationExternal, file_path::String, clean_and_prepare=true)\n\nRetrieves external data from disk given a path. Optionally cleans and prepares the data after loading. Handles both CSV and JLD2 file formats where the CSV should be a file pointing to a list of JLD2 files.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.load_data_from_disk-Tuple{String, Vector{String}, String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.load_data_from_disk","text":"load_data_from_disk(path::String, tickers::Vector{String})\n\nLoads specific tickers' data from the provided path on the disk. Returns an ExternalDataCollection containing the loaded data.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.load_data_from_disk-Tuple{Vector{String}, Vector{String}, String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.load_data_from_disk","text":"load_data_from_disk(path::Vector{String}, tickers::Vector{String})\n\nLoads specific tickers' data from multiple disk paths. Aggregates the data from all paths into a single ExternalDataCollection.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.resolution_to_dir-Tuple{String, String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.resolution_to_dir","text":"resolution_to_dir(resolution::String)\n\nMaps a data resolution string (like \"1d\" or \"1m\") to its respective directory path. Helpful for organizing data storage based on the resolution of the data.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.save_file-Tuple{TFire.ExternalDataHandler.ExternalDataFile, String, String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.save_file","text":"save_file(filename::String, edf::ExternalDataFile; overwrite=false)\n\nPersistently saves the ExternalDataFile to disk under the specified filename.  If overwrite is set to true, it will replace any existing file with the same name.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.save_to_disk-Tuple{TFire.ExternalDataHandler.ExternalDataCollection, String, String}","page":"External Data Handler","title":"TFire.ExternalDataHandler.save_to_disk","text":"save_to_disk(edc::ExternalDataCollection, file_name::String; overwrite=false)\n\nSaves an ExternalDataCollection to the disk using the provided file name. Offers an option to overwrite an existing file with the same name.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_edh.html#External-Data-From-Internet","page":"External Data Handler","title":"External Data From Internet","text":"","category":"section"},{"location":"functions/functions_edh.html","page":"External Data Handler","title":"External Data Handler","text":"Modules = [ExternalDataHandler]\nPages   = [\"ExternalDataRead/ExternalDataFromInternet.jl\"]","category":"page"},{"location":"functions/functions_edh.html#TFire.ExternalDataHandler.fetch_external_data_from_internet-Union{Tuple{T}, Tuple{C}, Tuple{SpecificationStruct{C, T}, Type}} where {C<:AssetConstituents, T<:TFire.ExternalDataHandler.ExternalSpecification}","page":"External Data Handler","title":"TFire.ExternalDataHandler.fetch_external_data_from_internet","text":"fetch_external_data_from_internet(spec::Specification{C,T}, service::Type;\n                    clean_and_prepare=true, verbose_error=true ) where {C<:AssetConstituents, T<:ExternalSpecification}\n\nFetches external data for the given constituents ext_cons using the specified service.  Optionally cleans and prepares the data after fetching.\n\nspec: A specification of which external data constituents and data fields to fetch.\nservice: The internet data service to use (e.g., YahooData).\nclean_and_prepare: Whether or not to clean and prepare the data after fetching.\nverbose_error: If true, provide detailed error messages.\n\nReturns the fetched (and optionally cleaned) external data.\n\n\n\n\n\n","category":"method"},{"location":"external_data.html#ExternalDataHandler","page":"External Data Handler","title":"ExternalDataHandler","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"The External Data Handler is a free-standing submodule that handles fetching data from verious internet sources as well as loading and saving of raw data from local disk storage","category":"page"},{"location":"external_data.html#Basic-Usage","page":"External Data Handler","title":"Basic Usage","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"The three primary functions for interacting with external data are: ","category":"page"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"EDH.fetch_external_data_from_disk()\nEDH.save_to_disk()\nEDH.fetch_external_data_from_internet()","category":"page"},{"location":"external_data.html#Technicalities","page":"External Data Handler","title":"Technicalities","text":"","category":"section"},{"location":"external_data.html#ExternalData","page":"External Data Handler","title":"ExternalData","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"A mutable structure that encapsulates the raw data for a given ticker. It contains:","category":"page"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"data: A Dict holding the actual data.\nticker: Symbol or name identifying the data.\nresolution: Describes the granularity of the data.\nfrom and to: Defines the time interval for the data. The actual time series might not include data for the whole period if some is missing/nonexistant.","category":"page"},{"location":"external_data.html#ExternalDataCollection","page":"External Data Handler","title":"ExternalDataCollection","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"This structure holds a collection of ExternalData structures.","category":"page"},{"location":"external_data.html#External-Data-File","page":"External Data Handler","title":"External Data File","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"The primary tool/format used to save and retrieve external data is the ExternalDataFile. This struct is designed to consolidate different external data types and provide  a consistent way of accessing them.","category":"page"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"The ExternalDataFile is composed of:","category":"page"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"A specification, which describes the properties of the data (e.g., resolution and file format version).\nTickers, which associate specific symbols with their corresponding ExternalData.","category":"page"},{"location":"external_data.html#Resolution-and-Directory-Structure","page":"External Data Handler","title":"Resolution and Directory Structure","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"Data resolution determines where data is stored and accessed. The resolution_to_dir function helps translate resolution to the appropriate directory structure, ensuring consistent organization and easy retrieval. The currentrly supported resolutions are daily (1d) and minute (1m).","category":"page"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"CurrentModule = TFire","category":"page"},{"location":"external_data.html#Functions","page":"External Data Handler","title":"Functions","text":"","category":"section"},{"location":"external_data.html","page":"External Data Handler","title":"External Data Handler","text":"External Data Handler - Functions","category":"page"},{"location":"functions/functions_sfdb.html#SimpleFastDB-Functions","page":"SimpleFastDB","title":"SimpleFastDB - Functions","text":"","category":"section"},{"location":"functions/functions_sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"Modules = [TFire]\nPages   = [\"Core/SimpleFastDB.jl\", \"Core/TimeSeries.jl\"]","category":"page"},{"location":"functions/functions_sfdb.html#TFire.add_data_from_disk!-Tuple{SimpleFastDB, Any, SpecificationStruct}","page":"SimpleFastDB","title":"TFire.add_data_from_disk!","text":"add_data_from_disk!(sfdb::SimpleFastDB, full_data_path, spec::Specification; verbose=false)\n\nAdds data from disk to the SimpleFastDB based on the Specification.\n\nArguments\n\nsfdb: The SimpleFastDB to add data to \nfull_data_path: The full path to the data file on disk\nspec: The Specification defining what data to read\nverbose: Print progress info. Default false.\n\nFetches the required external data based on the Specification, reads it from  disk at the provided path, and adds it to the SimpleFastDB.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_sfdb.html#TFire.add_data_from_internet!-Tuple{SimpleFastDB, SpecificationStruct}","page":"SimpleFastDB","title":"TFire.add_data_from_internet!","text":"add_data_from_internet!(sfdb, spec; kwargs...)\n\nDownloads external data from the internet based on the Specification  and adds it to the SimpleFastDB sfdb.\n\nArguments\n\nsfdb: The SimpleFastDB to add data to\nspec: The Specification defining what data to download \ninternet_service: Service to use for downloading data. Default YahooData.\nverbose: Print progress info. Default false.\n\nUses the external data Specification to determine what data to download.  Fetches the data using the provided internet service.  Then calls addexternaldata! to add the downloaded data to the SimpleFastDB.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_sfdb.html#TFire.get_time_series-Tuple{SimpleFastDB, Any}","page":"SimpleFastDB","title":"TFire.get_time_series","text":"get_time_series(sfdb, ticker; resolution=\"1d\", interval=\"continuous\", date=Date(1,1,1))\n\nRetrieves the time series data for the given ticker from the provided SimpleFastDB,  based on the specified resolution, interval, and date.\n\nArguments\n\nsfdb: The SimpleFastDB to retrieve data from.\nticker: The ticker symbol to retrieve data for.  \nresolution: The resolution of the data, e.g. \"1d\". Default is \"1d\".\ninterval: Either \"continuous\" or \"1d\". Default is \"continuous\". \ndate: The specific date to retrieve data for (only used if interval=\"1d\"). Default is Date(1,1,1).\n\nReturns\n\nThe TimeSeries data for the given ticker, resolution, interval and date. \nReturns nothing if no data is found.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_sfdb.html#TFire.setup_simple_fast_db-Tuple{SpecificationStruct}","page":"SimpleFastDB","title":"TFire.setup_simple_fast_db","text":"setup_simple_fast_db(spec::SpecificationStruct; read_external=true,\nread_disk=false, data_path=\"\", internet_service=YahooFinance)\n\nSets up and returns a SimpleFastDB based on the given Specification. Data can be optionally read from disk or downloaded from the internet.\n\nArguments\n\nspec: The Specification to set up the SimpleFastDB for.\nread_external: Whether to download data from the internet. Default false.  \nread_disk: Whether to read data from disk. Default false.\ndata_path: The path to the data directory if reading from disk.\ninternet_service: Service to use for downloading data. Default YahooData.\n\nReturns\n\nThe constructed SimpleFastDB containing data according to the arguments.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_sfdb.html#TFire.ExternalDataHandler.DataFields-Tuple{TimeSeries}","page":"SimpleFastDB","title":"TFire.ExternalDataHandler.DataFields","text":"DataFields(ts::TimeSeries)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_sfdb.html#TFire.get_datafield-Tuple{TimeSeries, Symbol}","page":"SimpleFastDB","title":"TFire.get_datafield","text":"get_datafield(ts::TimeSeries, field::Symbol)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"specification.html#Specification","page":"Specification","title":"Specification","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"A Collection, a SimpleFastDB and ExternalData all have a Specification which specifies what data and at which dates are contained in them. Their respective SpecificationTypes are: CollectionSpecification, SFDBSpecification and ExternalDataSpecification. The Specifications are split up into two parts, a Constituents part and a DataFields part.","category":"page"},{"location":"specification.html#Constituents","page":"Specification","title":"Constituents","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The Constituents contain information about ticker symbols and timeperiods as well as resolution. In a Collection every Sample in an Asset is specified by the ticker, a beginning and end date in the Constituents.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The Constituents changes depending on if they represent a Collection, a SimpleFastDB or ExternalData. For example, even though there are one timeperiod per sample in a Collection, there are only one timeperiod per time series in a SimpleFastDB. Thus, Constituents may be translated between Collection, SimpleFastDB and ExternalData.","category":"page"},{"location":"specification.html#ConstituentsContinuous","page":"Specification","title":"ConstituentsContinuous","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The ConstituentsContinuous is used when the data for each ticker is continuous in time.For example daily close data for an asset that is traded daily.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"Fields:","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"ticker_ranges: An ordered dictionary linking tickers to vectors of datetime ranges, indicating time series intervals for each asset.\nresolution: Describes the data granularity, e.g., \"1d\", \"1m\".\nspecification_type: ExternalSpecification, CollectionSpecification or SFDBSpecification","category":"page"},{"location":"specification.html#ConstituentsDiscrete","page":"Specification","title":"ConstituentsDiscrete","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The ConstituentsDiscrete is used when the data for each ticker is discrete in time. For example when intraday data is to be fetched for several days for an asset that is traded only part of the day, like a stock.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"Fields:","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"dates: An ordered dictionary where each date references a ConstituentsContinuous, allowing representation of non-continuous data.\nresolution: Specifies the data granularity.\nspecification_type: ExternalSpecification, CollectionSpecification or SFDBSpecification","category":"page"},{"location":"specification.html#DataFields","page":"Specification","title":"DataFields","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"DataFields specifies which fields of data (suck as price, volume etc) are available in the Collection, SimpleFastDB or ExternalData.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"Fields:","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"fields: A Set of Symbols specifying data fields.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"When creating a new SpecificationCollection a preset set of DataFields may be included by passing a Symbol insted of a DataFields object to the constructor.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"Supported Symbols and their associated DataFields are:","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":":normal => [:open, :close, :adj_close, :adj_close_log, :high, :low, :volume]\n:reduced => [:adj_close, :adj_close_log]\n:all_adj_log => [:adj_close_log, :adj_open_log, :adj_high_log, :adj_low_log]","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"When nothing is specified, i.e. a SpecificationCollection is created without passing a DataFields object, the :normal DataFields are used.","category":"page"},{"location":"specification.html#Translations-Between-SpecificationTypes","page":"Specification","title":"Translations Between SpecificationTypes","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"While every type of Specification may be manually specified, an automatic translation is most commonly used. The most frequent procedure is to create a CollectionSpecification, which is then translated to a SFDBSpecification that is then translated to an ExternalDataSpecification.","category":"page"},{"location":"specification.html#CollectionSpecification-to-SFDBSpecification","page":"Specification","title":"CollectionSpecification to SFDBSpecification","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The function","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"specification_sfdb(spec::SpecificationStruct{C,T}; extend_first=Day(0),     extend_last=Day(1000)) where {C<:AssetConstituents,T<:CollectionSpecification}","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"translates a CollectionSpecification to a SFDBSpecification. The SFDBSpecification specifies one time series per ticker. The extend_first and extend_last parameters indicate how many days/minutes etc of data should be added to the beginning and end of the timeseries. If extend_first=0 and extend_last=0, the resulting SFDBSpecification will specify a timeseries that begins from the first datetime specified for that ticker in the CollectionSpecification and end with the last datetime.","category":"page"},{"location":"specification.html#SFDBSpecification-to-ExternalDataSpecification","page":"Specification","title":"SFDBSpecification to ExternalDataSpecification","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"A SFDBSpecification is converted to an ExternalDataSpecification by the function","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"specification_external(spec::SpecificationStruct{C,T}) where {C<:AssetConstituents,T<:SFDBSpecification}","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"The constituents are here kept as they are, but the data fields are modified to convert logarithmized data fields to their non logarithmized counterparts.","category":"page"},{"location":"specification.html","page":"Specification","title":"Specification","text":"CurrentModule = TFire","category":"page"},{"location":"specification.html#Functions","page":"Specification","title":"Functions","text":"","category":"section"},{"location":"specification.html","page":"Specification","title":"Specification","text":"For functions related to Specifications seeSpecification - Functions","category":"page"},{"location":"returns.html#Returns","page":"Returns","title":"Returns","text":"","category":"section"},{"location":"returns.html","page":"Returns","title":"Returns","text":"The two mainly used returns are defined as","category":"page"},{"location":"returns.html","page":"Returns","title":"Returns","text":"textCompound Return_i = left( fractextValue_i - textInitial ValuetextInitial Value right)","category":"page"},{"location":"returns.html","page":"Returns","title":"Returns","text":"textStep Return_i = left( fractextValue_i - textValue_i-1textValue_i-1 right)","category":"page"},{"location":"returns.html","page":"Returns","title":"Returns","text":"By default the compound_return() and step_return() methods use the FutureAdjClose DataView, which represents the closing price adjusted for dividens etc. Thus. by defafault they give the compound total return. While this is by far the most common way of measuring returns for an equity most return functions take the fut_price_type argument if for example a non adjusted price is to be used.","category":"page"},{"location":"returns.html","page":"Returns","title":"Returns","text":"CurrentModule = TFire","category":"page"},{"location":"returns.html#Functions","page":"Returns","title":"Functions","text":"","category":"section"},{"location":"returns.html","page":"Returns","title":"Returns","text":"For a list of related functions see Returns - Functions.","category":"page"},{"location":"external_data_disk.html#Fetching-Data-from-Disk","page":"Data From Disk","title":"Fetching Data from Disk","text":"","category":"section"},{"location":"external_data_disk.html","page":"Data From Disk","title":"Data From Disk","text":"To retrieve external data stored on a local disk. use: EDH.fetch_external_data_from_disk(ext_cons::ExternalConstituents, file_path::String; clean_and_prepare::Bool=true)","category":"page"},{"location":"external_data_disk.html","page":"Data From Disk","title":"Data From Disk","text":"ext_cons: Specifies which external data constituents to fetch. See Constituents\nfile_path: The location on disk where the data is stored.\nclean_and_prepare (optional, default is true): Whether to clean and prepare the data after retrieval.","category":"page"},{"location":"external_data_disk.html","page":"Data From Disk","title":"Data From Disk","text":"This function supports both CSV and JLD2 file formats where a .csv file is used only as list of .jld2 files. The returned data can optionally be cleaned and prepared for further use.","category":"page"},{"location":"external_data_disk.html#Saving-Data-to-Disk","page":"Data From Disk","title":"Saving Data to Disk","text":"","category":"section"},{"location":"external_data_disk.html","page":"Data From Disk","title":"Data From Disk","text":"You can save processed or fetched data onto your local disk using the EDH.save_to_disk(edc::ExternalDataCollection, file_name::String; overwrite=false)","category":"page"},{"location":"external_data_disk.html","page":"Data From Disk","title":"Data From Disk","text":"edc: An instance of ExternalDataCollection that you intend to save. See ExternalDataCollection\nfile_name: The desired name of the file where you wish to save the data. The full path will be designed by the resolution, see Resolution and Directory Structure\noverwrite (optional, default is false): Whether to overwrite an existing file with the same name.","category":"page"},{"location":"functions/functions_dataviews.html#DataViews-Functions","page":"DataViews","title":"DataViews - Functions","text":"","category":"section"},{"location":"functions/functions_dataviews.html","page":"DataViews","title":"DataViews","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_dataviews.html","page":"DataViews","title":"DataViews","text":"Modules = [TFire]\nPages   = [\"CollectionDataView.jl\", \"AssetDataView.jl\"]","category":"page"},{"location":"functions/functions_dataviews.html#TFire.DVLayerDictKey-Union{Tuple{T}, Tuple{Asset, Symbol, Union{Int64, Symbol}}, Tuple{Asset, Symbol, Union{Int64, Symbol}, Type{T}}} where T<:AssetLayer","page":"DataViews","title":"TFire.DVLayerDictKey","text":"DVLayerDictKey(asset::Asset, dict::Symbol, key::Union{Int64, Symbol},\n\nlayertype::Type{T}=AssetLayer) where T <: AssetLayer View of a key in a field dict of type Dict for layer of type `layertypeinassetThe datetimes are matched to those in theassetso thatDVLayerDictKey[x]gives the value in the dict of the layer field value corresponding toasset[x]`\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVLayerField-Union{Tuple{T}, Tuple{Asset, Symbol}, Tuple{Asset, Symbol, Type{T}}} where T<:AssetLayer","page":"DataViews","title":"TFire.DVLayerField","text":"DVLayerField(asset::Asset, field::Symbol, layer_type::Type{T}=AssetLayer) where T <: AssetLayer\n\nView of a field field for layer of type layer_type in asset  The datetimes are matched to those in the asset so that DVLayerField[x] gives the layer field value corresponding to asset[x]\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVLayerGetFunc-Union{Tuple{T}, Tuple{Asset, Function}, Tuple{Asset, Function, Type{T}}} where T<:AssetLayer","page":"DataViews","title":"TFire.DVLayerGetFunc","text":"DVLayerGetFunc(asset::Asset, func::Function, layer_type::Type{T}=AssetLayer) where T <: AssetLayer\n\nThe function func applied to layer of type layer_type in asset  The datetimes are matched to those in the asset so that DVLayerGetFunc[x] gives the function func func(asset.some_field[x])\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVLayerGetFuncPar-Union{Tuple{T}, Tuple{Asset, Function, Any}, Tuple{Asset, Function, Any, Type{T}}} where T<:AssetLayer","page":"DataViews","title":"TFire.DVLayerGetFuncPar","text":"DVLayerGetFuncPar(asset::Asset, func::Function, par::Any, layer_type::Type{T}=AssetLayer) where T <: AssetLayer\n\nThe function func that takes the additional parameter par applied to layer of type layer_type in asset The datetimes are matched to those in the asset so that DVLayerGetFuncPar[x] gives func(asset.some_field[x], par)\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVNonRepaintingLayerDictKey-Union{Tuple{T}, Tuple{Asset, Symbol, Union{Int64, Symbol}}, Tuple{Asset, Symbol, Union{Int64, Symbol}, Type{T}}} where T<:AssetLayer","page":"DataViews","title":"TFire.DVNonRepaintingLayerDictKey","text":"DVNonRepaintingLayerDictKey(asset::Asset, dict::Symbol, key::Union{Int64, Symbol}, layer_type::Type{T}=AssetLayer) where T <: AssetLayer\n\nView of a key in a field dict of type Dict for layer of type layer_type in asset \n\nThe datetimes are matched to those in the asset in a non repainting manner so that  DVNonRepaintingLayerDictKey[1:end]  equals the value in the dict of the layer field assets from minimum to maximum of  all datetimes inasset`. Useful for constructing non repainting layers. \n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVNonRepaintingTimeSeries-Tuple{Asset, Symbol}","page":"DataViews","title":"TFire.DVNonRepaintingTimeSeries","text":"DVNonRepaintingTimeSeries(asset::Asset, symbol::Symbol)\n\nView of data from associated time series in SFDB with the name symbol.\n\nThe datetimes are matched to those in the asset in a non repainting manner so that  DVNonRepaintingTimeSeries[1:end]  equals the time series assets from minimum to maximum of  all datetimes inasset`. Useful for constructing non repainting layers. \n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVNonRepaintingTimeSeriesBack-Tuple{Asset, Symbol, Int64}","page":"DataViews","title":"TFire.DVNonRepaintingTimeSeriesBack","text":"DVNonRepaintingTimeSeriesBack(asset::Asset, symbol::Symbol, back::Int64)\n\nView of data from associated time series in SFDB with the name symbol.\n\nThe datetimes are matched to those in the asset in a non repainting manner so that  DVNonRepaintingTimeSeriesBack[1:end]  equals the time series assets from minimum to maximum of  all datetimes inasset. Useful for constructing non repainting layers. Theback` variable represents the number of time steps to go back in time from the earlest datetime in the asset.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.DVTimeSeries-Tuple{Asset, Symbol}","page":"DataViews","title":"TFire.DVTimeSeries","text":"DVTimeSeries(asset::Asset, symbol::Symbol)\n\nView of data from associated time series in SFDB with the name symbol.\n\nThe datetimes are matched to those in the asset so that DVTimeSeries[x][y] gives the time series value corresponding to asset[x][y]\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.FutureAdjClose-Tuple{Asset}","page":"DataViews","title":"TFire.FutureAdjClose","text":"FutureAdjClose(asset::Asset)\n\nA view of adjusted close prices from the evaluation datetime and forward. The evaluated datetime is included. FutureAdjClose[x] gives a view of future adjusted close values  from the evaluate datetime of asset[x]\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.FutureAdjCloseDay-Tuple{Asset}","page":"DataViews","title":"TFire.FutureAdjCloseDay","text":"FutureAdjCloseDay(asset::Asset)\n\nA view of adjusted close prices from the evaluation date and forward at a daily resolution. The evaluated date  is included. FutureAdjCloseDay[x] gives a view of future adjusted close values from the evaluate date of asset[x]. Useful for calculations of daily returns from decisions made on higher resolution time frames.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_dataviews.html#TFire.FutureAdjCloseEvalToDay-Tuple{Asset}","page":"DataViews","title":"TFire.FutureAdjCloseEvalToDay","text":"FutureAdjCloseEvalToDay(asset::Asset)\n\nA view of adjusted close prices from the evaluation datetime and then forward at a daily resolution.  FutureAdjCloseDayToEval[x] gives a view of future adjusted close values from the evaluate datetime of asset[x] where FutureAdjCloseEvalToDay[x][1] is the adj close of the evaluated datetime and FutureAdjCloseEvalToDay[2] is the adj close of the associated date. Then follows adj close on a daily resolution. Useful for calculations of daily returns from decisions made on higher resolution time frames.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_settings.html#Settings-Functions","page":"Settings - Functions","title":"Settings - Functions","text":"","category":"section"},{"location":"functions/functions_settings.html","page":"Settings - Functions","title":"Settings - Functions","text":"CurrentModule = TFire","category":"page"},{"location":"external_data_adding_source.html#Adding-A-New-Data-Source","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"User defined internet data sources may be used by TFire in a seamless manner by defining the proper functions for a user defined Type that subtypes InternetDataSource.","category":"page"},{"location":"external_data_adding_source.html#Example","page":"Adding A New Data Source","title":"Example","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"This guide demonstrates how the user would add the (already included) YahooFinance data source in this way","category":"page"},{"location":"external_data_adding_source.html#Create-A-New-File","page":"Adding A New Data Source","title":"Create A New File","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"Create a new file YahooFinanceUser.jl in the CustomDataSources directory. In the that file, add the following code:","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"struct YahooFinance <: InternetDataSource end\n\nfunction available_data_fields(::Type{YahooFinance})\n    return DataFields(Set([:close, :adj_close, :open, :low, :high, :volume]))\nend\n\n\nfunction external_API_timeseries(::Type{YahooFinance}, ticker, from, to, requested_data_fields::DataFields; resolution=\"1d\", skip_missing=false)\n    # Intraday data cannot extend past last 60 days\n    if !(resolution in [\"1m\", \"2m\", \"5m\", \"15m\", \"30m\", \"60m\", \"90m\", \"1h\", \"1d\", \"5d\", \"1wk\", \"1mo\", \"3mo\"])\n        e = \"Yahoo Interval incorrectly specified\"\n        return ErrorResult(e)\n    end\n    if !issubset(requested_data_fields.fields, available_data_fields(YahooFinance).fields)\n        e = \"Requested data fields not available from Yahoo Finance\"\n        return ErrorResult(e)\n    end\n    if resolution == \"1d\"\n        to = to + Day(1)\n    end\n    start = round(Int64, datetime2unix(DateTime(from)))\n    stop = round(Int64, datetime2unix(DateTime(to)))\n    params = Dict(\"period1\" => start, \"period2\" => stop, \"interval\" => resolution)\n    url = \"https://query1.finance.yahoo.com/v8/finance/chart/\" * ticker\n\n    local r\n    local data\n    try\n        r = HTTP.get(url; query=params, retries=5)\n        data = JSON.parse(String(r.body))\n    catch e\n        return ErrorResult(e)\n    end\n\n    if !(haskey(data[\"chart\"][\"result\"][1], \"timestamp\"))\n        return ErrorResult()\n    end\n    timestamps = unix2datetime.(data[\"chart\"][\"result\"][1][\"timestamp\"])\n    quote_data = data[\"chart\"][\"result\"][1][\"indicators\"][\"quote\"][1]\n\n    result_data = Dict{Symbol,Vector}()\n    result_data[:volume] = quote_data[\"volume\"]\n    result_data[:open] = quote_data[\"open\"]\n    result_data[:close] = quote_data[\"close\"]\n    result_data[:low] = quote_data[\"low\"]\n    result_data[:high] = quote_data[\"high\"]\n\n    if resolution in [\"1m\", \"2m\", \"5m\", \"15m\", \"30m\", \"60m\", \"90m\", \"1h\"]\n        timestamps = timestamps + Hour(2)\n        result_data[:adj_close] = quote_data[\"close\"]\n        result_data[:adj_open] = quote_data[\"open\"]\n        result_data[:adj_low] = quote_data[\"low\"]\n        result_data[:adj_high] = quote_data[\"high\"]\n    else\n        timestamps = DateTime.(Date.(timestamps))\n        result_data[:adj_close] = data[\"chart\"][\"result\"][1][\"indicators\"][\"adjclose\"][1][\"adjclose\"]\n    end\n    result_data[:Index] = timestamps\n    return prepare_result(result_data, requested_data_fields, skip_missing)\nend\n\n\n","category":"page"},{"location":"external_data_adding_source.html#Include-The-File","page":"Adding A New Data Source","title":"Include The File","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"In your custom scripts or main file, add the following line to include the file: include(\"CustomDataSources/YahooFinance.jl\").","category":"page"},{"location":"external_data_adding_source.html#Fetching-Data-With-The-User-Defined-Source","page":"Adding A New Data Source","title":"Fetching Data With The User Defined Source","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"The function EDH.fetch_external_data_from_internet(ext_cons, service, data_fields; clean_and_prepare=true, verbose_error=true)","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"with service specified as YahooFinanceUser can now be used to fetch data from the user defined YahooFinanceUser source.","category":"page"},{"location":"external_data_adding_source.html#Explanation-Of-The-Code","page":"Adding A New Data Source","title":"Explanation Of The Code","text":"","category":"section"},{"location":"external_data_adding_source.html#Define-the-Data-Source","page":"Adding A New Data Source","title":"Define the Data Source","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"Create a struct for your data source. The struct should be a subtype of the abstract type InternetDataSource.","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"struct YahooFinanceUser <: InternetDataSource end","category":"page"},{"location":"external_data_adding_source.html#Step-2:-Declare-Available-Data-Fields","page":"Adding A New Data Source","title":"Step 2: Declare Available Data Fields","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"Define available data fields by returning a DataFields object with a list of field symbols.","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"function available_data_fields(::Type{YahooFinanceUser})\n    return DataFields([:close, :adj_close, :open, :low, :high, :volume])\nend","category":"page"},{"location":"external_data_adding_source.html#Step-3:-Implement-the-Data-Retrieval-Function","page":"Adding A New Data Source","title":"Step 3: Implement the Data Retrieval Function","text":"","category":"section"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"Define a function to fetch and process data from the data source. This function should accept the parameters: ticker, from, to and requested data fields. It should also specify the optional arguments resolution and skip_missing.","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"function external_API_timeseries(::Type{YahooFinanceUser}, ticker, from, to, requested_data_fields::DataFields; resolution=\"1d\", skip_missing=false)\n    # Validate and prepare API call parameters\n    ...\n    # API call and data parsing\n    ...\n    # Data processing and formatting\n    ...\n    # Return the prepared result\n    return prepare_result(result_data, requested_data_fields, skip_missing)\nend","category":"page"},{"location":"external_data_adding_source.html","page":"Adding A New Data Source","title":"Adding A New Data Source","text":"Here, result_data should be a Dict with Symbols linking to Vectors of timeseries. The symbol :Index should be the timestamp index.","category":"page"},{"location":"tutorials/tutorial_basics.html#Tutorial-Basic-Analysis-of-Time-Series-Data","page":"Basics","title":"Tutorial - Basic Analysis of Time Series Data","text":"","category":"section"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"The primary tool used to access and analyse time series is the Collection. It contains a list of Assets, where every Asset holds the various time series associated with a single asset. An Asset typically contains several views into the time series, where each view is a continuous subset of the whole time series. Each such view is called a Sample (see Samples).","category":"page"},{"location":"tutorials/tutorial_basics.html#Collection-Setup","page":"Basics","title":"Collection Setup","text":"","category":"section"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Below follows a simple example of how to setup a Collection.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> tickers = [\"MMM\", \"AOS\"]\n2-element Vector{String}:\n \"MMM\"\n \"AOS\"\n\nTFire> spec = Specification(tickers, Date(2001,6,2), Date(2018,6,8); extend_back=1800);\n\nTFire> collection = setup_collection(spec)\nSetting up collection\n||Collection|| (Continuous)\nTickers: 2, MMM AOS\nSamples: 8562","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"First the ticker symbols for the assets to be included are defined. Secondly a Specification is created. The \"evaluation dates\" are specified as all dates between 6/2/2001 and 6/8/2018. An evaluation date is the last date in the series of dates \"seen\" by one Sample. When a sample is later analyzed, no data beyond this date is visible to the analysis, preventing accidental \"look ahead\". The extend_back=1800 parameter gives each sample access to 1800 days of data proior to its evaluation date.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"The Specification also contains information about which DataFields to include in each sample. Here the defaults are used since no DataFields are explicitly specified.","category":"page"},{"location":"tutorials/tutorial_basics.html#Adding-Layers","page":"Basics","title":"Adding Layers","text":"","category":"section"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"The Collection provides an interface to attach Layers to a time series. A layer is a condensate of data associated with the time series. Layers may also be, as the name suggests, layered. For example, the first layer could be a pair of Exponential Moving Averages (EMAs) of the price of an asset and the second layer could then be the Moving Average Convergence Divergence (MACD) based on that pair of EMAs.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Example of adding layers:","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> settings = Settings()\n\nTFire> settings[LayerEMA][:win_sizes] =  [12,26];\n\nTFire> collection_ema = add_layer(collection, LayerEMA, settings=settings)\n||Collection|| (Continuous) -> LayerEMA\nTickers: 2, MMM AOS\nSamples: 8514\n\nTFire> collection_macd = add_layer(collection_ema, LayerMACD)\n||Collection|| (Continuous) -> LayerEMA -> LayerMACD\nTickers: 2, MMM AOS\nSamples: 8514","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Here the concept of Collection Settings is introduced. This is where parameters for Layers live. They may also contain other types of parameters, which we will soon see. It should be noted that settings was not needed when adding the MACD layer since it was already attached to collection_ema at its creation.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Let's have a look at all the settings that has been used","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> collection_macd.settings_used\nLayerMACD\n:signal_period => 9\n:long_period => \"maximum\"\n:short_period => \"minimum\"\n   ---\nTSDLink\n:resolution => \"1d\"\n:default_price_field => :adj_close_log\n   ---\nLayerEMA\n:win_sizes => [12, 26]\n   ---","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"LayerMACD has settings even though no parameters were specified. This is because all Layers come with default parameters that are used if some parameter is omitted. The parameters for TSDLink specifies the resolution of the time series related to the Collection and which data field that is to be used when a layer requests the \"price\" of an asset. Here, the adjusted logarithmic closing price will then be used if nothing else is specified for a particular layer.","category":"page"},{"location":"tutorials/tutorial_basics.html#Plotting-the-Graph-for-a-Sample","page":"Basics","title":"Plotting the Graph for a Sample","text":"","category":"section"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Let's look at the default graph for the first sample of the Asset with ticker MMM.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> plot_graph(collection_macd, \"MMM\", 1)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"(Image: MACD Graph) Notice how the graph ends at 2 jun 2001 coinciding with the evaluation date of the first sample. No data beyond this date is visible to this particular sample.","category":"page"},{"location":"tutorials/tutorial_basics.html#Analysis","page":"Basics","title":"Analysis","text":"","category":"section"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Let's say we have a theory that any time the MACD histogram changes sign from negative to positive this signals a possible short term trend change. We can filter out all samples where the evaluation date has a positive value in the MACD histogram and the previous date is negative.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"First we set up a function that returns true if a vector has a positive last value and a negative second to last value.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> function macd_signal(input)\n         macd_hist = input[1]\n         return macd_hist[end-1] < 0 && macd_hist[end] > 0\n       end","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Secondly, we need to define a DataView. For now, all we need to know is that a Data View provides a view of some data in a Collection. Here a view of the MACD histogram from the MACD Layer. For a more comprehensive explanation of Data Views see DataViews.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> dv_macd = DVLayerField(collection_macd, :macd_histogram, LayerMACD);","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Now we can filter the Collection with the Data View and the predefined function. If the function returns true we want to keep the sample (thus action=:keep), otherwise throw it away.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> collection_macd_filtered = filter_collection(collection_macd, dv_macd, macd_signal)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Let's have a look at how many dates that were kept after the filtering.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> collection_macd_filtered\n||Collection|| (Continuous) -> LayerEMA -> LayerMACD\nTickers: 2, MMM AOS\nSamples: 346","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"And how they are split between the two assets.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> collection_macd_filtered[\"MMM\"]\n||Collection|| (Continuous) -> LayerEMA -> LayerMACD\nTicker: MMM\nSamples: 171\n\nTFire> collection_macd_filtered[\"AOS\"]\n||Collection|| (Continuous) -> LayerEMA -> LayerMACD\nTicker: AOS\nSamples: 175","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"We can calculate the average returns for the resulting filtered collection collection_macd_filtered. Then an envelop of all possible best and worst returns of some subset with x number of samples of the whole of collection_macd may be plotted.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> plot_envelope(collection_macd_filtered, collection_macd; steps=10)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"(Image: Envelope)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"The horizontal line marks the average return of collection_macd. We can see that the filtered dates performed worse than the average date and significantly worse than the optimal choice of 353 dates/samples.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"10 days might be a bad choice. Maybe some other period may prove to give a better result...","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"TFire> mean_return_filtered = mean_compound_return(collection_macd_filtered, 150);\nTFire> mean_return_original = mean_compound_return(collection_macd, 150);\nTFire> diff_return = mean_return_filtered .- mean_return_original;\nTFire> plot(diff_return, label=\"Filtered - All\", legend=:topright)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"(Image: Diff Returns)","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"Here, we calculated the difference between the average return of the filtered Collection and the average return of the original Collection for each possible step length. I.e element x in diff_return corresponds to the difference in average return after x steps.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"We then plot this difference. From the plot we can see that the case for selecting dates to take a long position gets slightly better if we are looking to stay in the trade for a longer period but it never gets very convincing.","category":"page"},{"location":"tutorials/tutorial_basics.html","page":"Basics","title":"Basics","text":"In Tutorial - Backtesting we instead look at how to do basic portfolio backtesting on a simple strategy.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"CurrentModule = TFire","category":"page"},{"location":"layers.html#Layers","page":"Layers","title":"Layers","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"A Layer may be thought of as a more generalized form of a technical indicator. Every Collection may contain one or more Layers. All Assets in a Collection contain the same Layers. Layers are always stacked on top of each other in a chain, where each Layer may use information from the Layers below as well as the raw time series data associated with the Collection. ","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Layers provide increased flexibility compared to ordinary technical indicators. For example, an MACD or a Bollinger Bands Layer may be created upon any moving average layer (SMA, EMA etc).","category":"page"},{"location":"layers.html#Adding-Layers","page":"Layers","title":"Adding Layers","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"A new layer is added with the add_layer() function.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Example:","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"TFire> collection_sma = add_layer(collection, LayerSMA);\n\nTFire> collection_macd = add_layer(collection_sma, LayerMACD);","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Here an SMA Layer is added to the Collection collection creating a new Collection collection_sma. An MACD Layer is then added to collection_sma creating collection_macd.","category":"page"},{"location":"layers.html#Adding-Several-Layers-At-Once","page":"Layers","title":"Adding Several Layers At Once","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"A Layer further down the chain may be added directly if at least one of the following criteria is true:","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Only one possible chain of layers to the output layer exists.\nThe settings provided uniquely specify which layers to add.\nThe function defaultlayerover(LayerType) exists for all relevant layers.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Further, in the case that all layers up to and including the requested output layer already exist in the collection, the layers that has seen changed settings will be redone.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Example:","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"TFire> collection_macd = add_layer(collection, LayerMACD);\nError. Settings not unique. Can not determine which layers to produce\nNo layers added\n\nTFire> collection.settings\nTSDLink\n:resolution => \"1d\"\n:default_price_field => :adj_close_log\n   ---\n\nTFire> collection.settings[LayerSMA] = Parameters(LayerSMA, :win_sizes => [12,26])\n\nTFire> collection.settings\nTSDLink\n:resolution => \"1d\"\n:default_price_field => :adj_close_log\n   ---\nLayerSMA\n:win_sizes => [12, 26]\n   ---\n\nTFire> collection_macd = add_layer(collection, LayerMACD)\n-| Collection |- (Continuous) -> LayerSMA -> LayerMACD\nTickers: 399, MMM to ZION\nSamples: 798446","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Above, a Layer to pick above LayerMACD is first not uniquely specified, and thus an error is thrown. Settings for LayerSMA are then added to the Collection and LayerMACD may be added. In reality though, the default_layer_over() function would determine that LayerSMA is the only possible layer above LayerMACD.","category":"page"},{"location":"layers.html#Listing-Available-Layers","page":"Layers","title":"Listing Available Layers","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Available layertypes may be listed with the list_available_layertypes() function.","category":"page"},{"location":"layers.html#Repainting-vs-NonRepainting","page":"Layers","title":"Repainting vs NonRepainting","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Technical indicators may be repainting (also called noncausal) or nonrepainting (causal) and naturally the same goes for Layers in TFire. A repainting indicator may update past values depending on future information while a nonrepainting one may not. TFire is designed to be able to handle repainting indicators (Layers) without introducing look ahead-bias.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"note: Note\nThere can never be a nonrepainting layer below a repainting one. However there CAN be a repainting layer below a nonrepainting one.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"To check if a layer is repainting or nonrepainting, use the LayerRepaintingTrait() function.","category":"page"},{"location":"layers.html#Creating-New-Layer-Types","page":"Layers","title":"Creating New Layer Types","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"For a guide on how to define new layers see Creating User Defined Layers.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"<!--- dev:start --->","category":"page"},{"location":"layers.html#Add-Layer-Under-The-Hood-(Developer)","page":"Layers","title":"Add Layer - Under The Hood (Developer)","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"To go from an empty collection to a collection with LayerMACD in it we need to know which layers to add and their respective settings and then try to add all necessary layers. Below, all the fundametal steps when calling","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"TFire> add_layer(collection, LayerMACD, new_settings)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"is explained. ","category":"page"},{"location":"layers.html#1,-Settings-Are-Determined","page":"Layers","title":"1, Settings Are Determined","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"First","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"settings = add_and_replace_parameters(deepcopy(collection.settings), settings)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"is called. Here, all settings in new_settings are added to collection.settings. Existning parameters of same kind are replaced.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Secondly","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"check_settings_valid(settings)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"is run just to check if the settings are valid, i.e. all parameters in settings exists.","category":"page"},{"location":"layers.html#2,-Layers-to-Add-Are-Determined","page":"Layers","title":"2, Layers to Add Are Determined","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Now, the layers to add are determined.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"lay_to_add = layers_to_add(collection, output_type, settings)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"The layers_to_add method returns a vector with the layer types that should be added to collection in ascending order.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Below is an overview of the overarching logic.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Firstly, layers_over() play an important role. Let's see how it works.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"TFire> layers_over(LayerMACD)\n(Type[CalculateOnMA, AbstractMovingAverage], Vector{Type}[[LayerMACD], [LayerEMA, LayerSMA]])","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"It returns two vectors, where the first represent the abstract layer types above LayerMACD and the second vector represents all sets of concrete layer types including LayerMACD. We can see that above LayerMACD there are two possible concrete layers, i.e. LayerEMA, LayerSMA which are the two concrete subtypes of AbstractMovingAverage. The list of concrete layers are stored in layers_until_output_concrete.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"It then goes through four possible cases, stopping at the first that is true.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"1, No Layers PresentIf no layers are present in the collection the settings are checked to see if a unique set of concrete layer types can be determined for every layer on the way to the output layer. This is done by filtering layers_until_output_concrete by which layers have settings and see if all steps only has settings for one concrete layer. If so those are returned.2, Output Layer in Chain to Current LayerChecks to see if requested output layer is in the chain of layers above the current top layer. If that is the case the settings for the leyers up until requested output layer are checked to see if they differ from those used for the current layers. If the settings differ for any layer, all layers that build on that layer is redone.3, Current Top Layer in Chain to Requested Output LayerChecks if current layers are part of the way to the requested output layer. If so then first checks if settings has changed for any of the current layers and just as in case 2 all layers below a layer with changed settings is redone. After this all additional layers between the curren topmost layer and the requested output layer is done. Settings again, needs to be unique for all concrete layer types.4,  All Else Fail Do All LayersAll layers up to and including output layer are done. This case is basically the same as case 1. Maybe they could be merged in the future.","category":"page"},{"location":"layers.html#3,-Assets-to-Keep-are-Determined-and-Copied","page":"Layers","title":"3, Assets to Keep are Determined and Copied","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"The assets of the collection are checked against the list of layers to be added. Since the layers that needs to be added and or redone has already been determined we can pick the assets with the first layer above these, of if that doesn't exist start from TSDLink. These assets are then copied.","category":"page"},{"location":"layers.html#4,-Layers-are-Added-and-Settings-Updated","page":"Layers","title":"4, Layers are Added and Settings Updated","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"The _add_layer_to_assets method is called on the assets once for every Layer to add. It constructs the layer for all assets and adds them to a new Assets struct.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Before every individual asset is created,","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"common_input = _layer_input_in_common_for_all_assets(output_type, assets, settings)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"is called. Here calculations that are not tied to any individual Asset is performed.","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Then _add_new_layer  is called once for every ticker in the collection or once for every date and ticker in the case of Discrete Assets, see [Discrete Assets].","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"The _add_new_layer function does two things. First it calls _produce_layer","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"new_layer, index_to_keep = _produce_layer(output_type, asset, settings, settings_used, common_input=common_input)","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"<!--- dev:end --->","category":"page"},{"location":"layers.html#Functions","page":"Layers","title":"Functions","text":"","category":"section"},{"location":"layers.html","page":"Layers","title":"Layers","text":"Layers - Functions","category":"page"},{"location":"layers.html","page":"Layers","title":"Layers","text":"```","category":"page"},{"location":"functions/functions_layers.html#Layers-Functions","page":"Layers - Functions","title":"Layers - Functions","text":"","category":"section"},{"location":"functions/functions_layers.html","page":"Layers - Functions","title":"Layers - Functions","text":"CurrentModule = TFire","category":"page"},{"location":"functions/functions_layers.html","page":"Layers - Functions","title":"Layers - Functions","text":"Modules = [TFire]\nPages   = [\"Core/CollectionLayers.jl\", \"Core/AssetLayer.jl\"]","category":"page"},{"location":"functions/functions_layers.html#TFire.add_layer-Union{Tuple{T}, Tuple{Collection, Type{T}}} where T<:AssetLayer","page":"Layers - Functions","title":"TFire.add_layer","text":"add_layer(collection::Collection,  output_type::Type{T};\n                    settings::Settings=Settings()) where T <: AssetLayer\n\nAdds layers to collection. Which layers are added/updated determined by logic in function layerstoadd.\n\nIf settings are provided they override the settings in the collection for all layers included\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.has_unique_settings-Union{Tuple{T}, Tuple{Settings, Array{Vector{T}, 1}}} where T<:Type","page":"Layers - Functions","title":"TFire.has_unique_settings","text":"has_unique_settings(settings::Settings, slc::Vector{Vector{Type}})\n\nReturns true if only one of the provided layers for each batch of layers has associated settings.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.has_unique_settings-Union{Tuple{T}, Tuple{Settings, Vector{T}}} where T<:Type","page":"Layers - Functions","title":"TFire.has_unique_settings","text":"has_unique_settings(settings::Settings, slc::Vector{Type})\n\nReturns true if only one of the provided layers has associated settings.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.layers_affected_by_changed_settings-Tuple{Settings, Settings, Vector{Type}}","page":"Layers - Functions","title":"TFire.layers_affected_by_changed_settings","text":"layers_affected_by_changed_settings(settings::Settings, settings_used::Settings,\n                                        layers::Vector{Type})\n\nReturns a vector with all layers where changes have occured in settings and their superlayers. The order of the input vector of layers is kept.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.layers_over-Tuple{Type}","page":"Layers - Functions","title":"TFire.layers_over","text":"layers_over(layer_type::Type{T}) where T <: AssetLayer\n\nReturns the two vectors (layersabstract, layersconcrete) where layersabstract includes all abstract superlayers to layertype in descending order. layersconcrete is a vector in descending order where every asset is a vector of possible concrete superlayers to layertype. \n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.layers_to_add-Tuple{Collection, Type, Settings}","page":"Layers - Functions","title":"TFire.layers_to_add","text":"layers_to_add(collection::Collection,  output_type::Type{T}) where T <: AssetLayer\n\nReturns a vector with the layer types that should be added to collection in ascending order.\n\nThe function handles the following logic; All layers that has to be added/remade up to output_type should be included. Layers (including all sublayers) should be redone if settings for that layer has changed. In the case were several parallell concrete layers exists settings must be exclusive.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.unique_settings-Union{Tuple{T}, Tuple{Settings, Array{Vector{T}, 1}}} where T<:Type","page":"Layers - Functions","title":"TFire.unique_settings","text":"unique_settings(settings::Settings, slc::Vector{Vector{Type}})\n\nReturns a vector of the types that has unique settings. Should only be called if hasuniquesettings is true.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.unique_settings-Union{Tuple{T}, Tuple{Settings, Vector{T}}} where T<:Type","page":"Layers - Functions","title":"TFire.unique_settings","text":"unique_settings(settings::Settings, slc::Vector{Type})\n\nReturns the type that has unique settings. Should only be called if hasuniquesettings is true.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.LayerRepaintingTrait-Tuple{Type{<:AssetLayer}}","page":"Layers - Functions","title":"TFire.LayerRepaintingTrait","text":"LayerRepaintingTrait(::Type{<:AssetLayer})\n\nGets the repainting trait of the given AssetLayer subtype. Returns either  Repainting() or NonRepainting(). This determines whether the layer will repaint  underlying data when new data is added.\n\n\n\n\n\n","category":"method"},{"location":"functions/functions_layers.html#TFire.list_available_layertypes-Tuple{}","page":"Layers - Functions","title":"TFire.list_available_layertypes","text":"list_available_layertypes(;layer_type=AssetLayer, spacer=\"\")\n\nPrints a tree of available layer types.\n\n\n\n\n\n","category":"method"},{"location":"external_data_sources.html#Internet-Data-Sources","page":"Internet Data Sources","title":"Internet Data Sources","text":"","category":"section"},{"location":"external_data_sources.html#Yahoo-Finance","page":"Internet Data Sources","title":"Yahoo Finance","text":"","category":"section"},{"location":"external_data_sources.html","page":"Internet Data Sources","title":"Internet Data Sources","text":"Available Data Fields for Yahoo Data are :close, :adj_close, :open, :low, :high, :volume\nAvailable tick sizes (resolution) for the last 60 days are 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h \nAvailable tick sizes (resolution) for other time periods are 1d, 5d, 1wk, 1mo, 3mo ","category":"page"},{"location":"index.html#TFire","page":"Introduction","title":"TFire","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"TFire is tool designed for finding and testing trading strategies on financial time series data. It combines the best properties of leading Python backtesting frameworks but is written in Julia. It is fully scriptable (in Julia) and extensible and accessed via a REPL.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you want to dive right into it a recommended starting point is the Tutorial - Basic Analysis of Time Series Data.","category":"page"},{"location":"index.html#Julia","page":"Introduction","title":"Julia","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"TFire comes with the Julia language ecosystem. Anyone comfortable with scripting in Python will pick up scripting in Julia within a few days. The main advantage over Python for a backtesting application is speed and memory efficiency. While additions to Python like Numba, Cython and lately Mojo can deliver similar efficiency as Julia, none of them are as flexible and mature.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An introduction to Julia: https://mint.westdri.ca/julia/intro_intro","category":"page"},{"location":"index.html#Installing-and-Running","page":"Introduction","title":"Installing and Running","text":"","category":"section"},{"location":"index.html#Windows","page":"Introduction","title":"Windows","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Download TFire folder for Windows and place it at your desired location.\nNavigate to the TFire folder and run run_tfire.bat","category":"page"},{"location":"index.html#MacOS","page":"Introduction","title":"MacOS","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Download TFire folder for MacOS and place it at your desired location.\nOpen a command prompt in the TFire folder and write ./run_tfire.sh","category":"page"},{"location":"index.html#Exit-TFire","page":"Introduction","title":"Exit TFire","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To exit TFire write exit() at the prompt.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = TFire","category":"page"},{"location":"sfdb.html#SimpleFastDB","page":"SimpleFastDB","title":"SimpleFastDB","text":"","category":"section"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"The SimpleFastDB is an in-memory database which contains all time series data used by Collections and Portfolios. This data usually consist of raw external data or trivially modified such. This external data is commonly obtained through the ExternalDataHandler.","category":"page"},{"location":"sfdb.html#TimeSeries","page":"SimpleFastDB","title":"TimeSeries","text":"","category":"section"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"The SimpleFastDB stores TimeSeries objects. A TimeSeries object contains a number of continuous time series for one ticker. Thus if times series data from several discontinuous times are stored in the SimpleFastDB, they will be stored as separate TimeSeries objects. Currently only daily discrete time series are supported.","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"Every TimeSeries contains an index vector of the associated datetimes. Further, it supports any ammount of DataFields where every such DataField represents a vector of values. To access a DataField the one may use the function","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"get_datafield(ts::TimeSeries, field::Symbol)","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"A list of the available DataFields can be obtained with","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"DataFields(ts::TimeSeries)","category":"page"},{"location":"sfdb.html#Creating-a-SimpleFastDB","page":"SimpleFastDB","title":"Creating a SimpleFastDB","text":"","category":"section"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"A new SimpleFastDB is created with the function","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"setup_simple_fast_db(spec::Specification; read_external=true, read_disk=false, data_path = \"\", internet_service=YahooData)","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"Besides the obligatory Specification argument this function takes the following optional arguments:","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"read_external - Bool, if true the SimpleFastDB will read external data from online sources.\nread_disk - Bool, if true the SimpleFastDB will read data from disk.\ndata_path - String, the path to the data file(s) to read if read_disk=true.\ninternet_service - String, the internet service to use if read_external=true.","category":"page"},{"location":"sfdb.html#Accessing-a-TimeSeries","page":"SimpleFastDB","title":"Accessing a TimeSeries","text":"","category":"section"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"Time series will usually be accessed through Collections but may also be accessed directly from a SimpleFastDB. Access to a TimeSeries is carried out with the function","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"get_time_series(sfdb::SimpleFastDB, resolution::String, interval::String, ticker::String; date=Date(0001,1,1)) method is used.","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"resolution - String, the resolution of the TimeSeries.\ninterval - String, \"continuous\" or \"1d\". Specifies if the TimeSeries is continuous or daily (like a daily traded stock on some resolution finer than daily).\nticker - String, the ticker of the TimeSeries.\ndate - Date, the date of the TimeSeries in case interval=\"1d\".","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"CurrentModule = TFire","category":"page"},{"location":"sfdb.html#Functions","page":"SimpleFastDB","title":"Functions","text":"","category":"section"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"For functions related to the Collection see SimpleFastDB - Functions.","category":"page"},{"location":"sfdb.html","page":"SimpleFastDB","title":"SimpleFastDB","text":"\n","category":"page"}]
}
